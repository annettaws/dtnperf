diff -r 7d8695f45fe0 -r a42ec85b1a6c applib/APIServer.cc
--- a/applib/APIServer.cc	Mon Jan 07 23:33:49 2013 +0000
+++ b/applib/APIServer.cc	Wed Jan 09 13:39:06 2013 +0000
@@ -1077,6 +1077,14 @@
     for (u_int i = 0; i < spec.blocks.blocks_len; i++) {
         dtn_extension_block_t* block = &spec.blocks.blocks_val[i];
 
+        // Reject illegal extension blocks
+        if ((block->type == BundleProtocol::PRIMARY_BLOCK) ||
+        	(block->type == BundleProtocol::PAYLOAD_BLOCK) ||
+        	(block->type == BundleProtocol::METADATA_BLOCK)) {
+        	log_err("Illegal extension block type (%d) detected", block->type);
+        	return DTN_EINVAL;
+        }
+
         BlockProcessor* new_bp = BundleProtocol::find_processor(block->type);
         if (new_bp == UnknownBlockProcessor::instance()) {
         	new_bp = APIBlockProcessor::instance();
@@ -1101,6 +1109,13 @@
     for (unsigned int i = 0; i < spec.metadata.metadata_len; ++i) {
         dtn_extension_block_t* block = &spec.metadata.metadata_val[i];
 
+        // Expecting only block type METADATA_BLOCK
+        if (block->type != BundleProtocol::METADATA_BLOCK){
+        	log_err("Metadata block with block type (%d) other than %d detected",
+        			block->type, BundleProtocol::METADATA_BLOCK);
+        	return DTN_EINVAL;
+        }
+
 #if 0
         // XXX/Elwyn - this is just plain wrong!  This puts the RFC5050 block
         // type in the ontology slot for the MetadataBlock (partly due to the
diff -r 7d8695f45fe0 -r a42ec85b1a6c apps/dtnsend/dtnsend.cc
--- a/apps/dtnsend/dtnsend.cc	Mon Jan 07 23:33:49 2013 +0000
+++ b/apps/dtnsend/dtnsend.cc	Wed Jan 09 13:39:06 2013 +0000
@@ -455,6 +455,7 @@
     char arg_type = 0;
     bool flags_set, data_set;
     u_int64_t ontology;
+    int block_type;
 
     progname = argv[0];
 
@@ -553,7 +554,14 @@
             sleep_time = atoi(optarg);
             break;
         case 'E':
-            ext_blocks.push_back(ExtBlock(atoi(optarg)));
+        	block_type = atoi(optarg);
+        	if ((block_type == PRIMARY_BLOCK) ||
+        		(block_type == PAYLOAD_BLOCK) ||
+        		(block_type == METADATA_BLOCK)) {
+        		fprintf(stderr, "-E - extension blocks must not be PRIMARY, PAYLOAD or METADATA (0, 1 or 8).\n");
+        		exit(1);
+        	}
+            ext_blocks.push_back(ExtBlock(block_type));
             flags_set = false;
             data_set = false;
             break;
diff -r 7d8695f45fe0 -r a42ec85b1a6c apps/dtnsource/dtnsource.cc
--- a/apps/dtnsource/dtnsource.cc	Mon Jan 07 23:33:49 2013 +0000
+++ b/apps/dtnsource/dtnsource.cc	Wed Jan 09 13:39:06 2013 +0000
@@ -416,6 +416,7 @@
     int c, done = 0;
     bool flags_set, data_set;
     u_int64_t ontology;
+    int block_type;
 
     progname = argv[0];
 
@@ -511,7 +512,14 @@
             sleep_time = atoi(optarg);
             break;
         case 'E':
-            ext_blocks.push_back(ExtBlock(atoi(optarg)));
+        	block_type = atoi(optarg);
+        	if ((block_type == PRIMARY_BLOCK) ||
+        		(block_type == PAYLOAD_BLOCK) ||
+        		(block_type == METADATA_BLOCK)) {
+        		fprintf(stderr, "-E - extension blocks must not be PRIMARY, PAYLOAD or METADATA (0, 1 or 8).\n");
+        		exit(1);
+        	}
+            ext_blocks.push_back(ExtBlock(block_type));
             flags_set = false;
             data_set = false;
             break;
diff -r 00bddbb095de -r 7d8695f45fe0 applib/APIServer.cc
--- a/applib/APIServer.cc	Fri Jan 04 17:01:21 2013 +0000
+++ b/applib/APIServer.cc	Mon Jan 07 23:33:49 2013 +0000
@@ -1072,6 +1072,8 @@
     }
 
     // extension blocks
+    // Save time by pre-allocating the vector
+    b->api_blocks()->reserve(spec.blocks.blocks_len + spec.metadata.metadata_len);
     for (u_int i = 0; i < spec.blocks.blocks_len; i++) {
         dtn_extension_block_t* block = &spec.blocks.blocks_val[i];
 
@@ -1557,40 +1559,53 @@
 
     for (unsigned int i = 0; i < b->recv_metadata().size(); ++i) {
         blocks_found++;
-        data_len += b->recv_metadata()[i]->metadata_len();
+        data_len += SDNV::encoding_len(b->recv_metadata()[i]->ontology()) +
+        		    b->recv_metadata()[i]->metadata_len();
     }
     if (vec != NULL) {
 		for (unsigned int i = 0; i < vec->size(); ++i) {
 			blocks_found++;
-			data_len += (*vec)[i]->metadata_len();
+			data_len += SDNV::encoding_len((*vec)[i]->ontology()) +
+					    (*vec)[i]->metadata_len();
 		}
     }
 
     if (blocks_found > 0) {
         unsigned int buf_len = (blocks_found * sizeof(dtn_extension_block_t)) +
                                data_len;
+        int ol;
         void * buf = (char *)malloc(buf_len);
         memset(buf, 0, buf_len);
 
         dtn_extension_block_t * bp = (dtn_extension_block_t *)buf;
         char * dp = (char*)buf + (blocks_found * sizeof(dtn_extension_block_t));
+        char * idp = dp;
         for (unsigned int i = 0; i < b->recv_metadata().size(); ++i) {
-            bp->type          = b->recv_metadata()[i]->ontology();
+            bp->type          = BundleProtocol::METADATA_BLOCK;
             bp->flags         = b->recv_metadata()[i]->flags();
             bp->data.data_len = b->recv_metadata()[i]->metadata_len();
             bp->data.data_val = dp;
+			ol = SDNV::encode(b->recv_metadata()[i]->ontology(), dp, buf_len - (dp - idp));
+			ASSERT(ol > 0);
+			dp += ol;
             memcpy(dp, b->recv_metadata()[i]->metadata(), bp->data.data_len);
             dp += bp->data.data_len;
+            bp->data.data_len += ol;
             bp++;
         }
         if (vec != NULL) {
 			for (unsigned int i = 0; i < vec->size(); ++i) {
-				bp->type          = (*vec)[i]->ontology();
+				bp->type          = BundleProtocol::METADATA_BLOCK;
+				;
 				bp->flags         = (*vec)[i]->flags();
 				bp->data.data_len = (*vec)[i]->metadata_len();
 				bp->data.data_val = dp;
+				ol = SDNV::encode((*vec)[i]->ontology(), dp, buf_len - (dp - idp));
+				ASSERT(ol > 0);
+				dp += ol;
 				memcpy(dp, (*vec)[i]->metadata(), bp->data.data_len);
 				dp += bp->data.data_len;
+	            bp->data.data_val += ol;
 				bp++;
 			}
         }
diff -r 00bddbb095de -r 7d8695f45fe0 apps/dtnpeek/dtnpeek.c
--- a/apps/dtnpeek/dtnpeek.c	Fri Jan 04 17:01:21 2013 +0000
+++ b/apps/dtnpeek/dtnpeek.c	Mon Jan 07 23:33:49 2013 +0000
@@ -28,6 +28,7 @@
 #include <sys/stat.h>
 #include <fcntl.h>
 #include "dtn_api.h"
+#include "sdnv-c.h"
 
 #define BUFSIZE 16
 #define BLOCKSIZE 8192
@@ -378,6 +379,7 @@
     dtn_bundle_spec_t spec;
     dtn_bundle_payload_t payload;
     int call_bind;
+    u_int64_t ontology;
 
     // force stdout to always be line buffered, even if output is
     // redirected to a pipe or file
@@ -562,10 +564,21 @@
                spec.metadata.metadata_len, spec.source.uri, 0);
         dtn_extension_block_t *meta = spec.metadata.metadata_val;
         for (k = 0; k < spec.metadata.metadata_len; k++) {
-            printf("Metadata Extension Block %i:\n", k);
-            printf("\ttype = %i\n\tflags = %i\n",
-                   meta[k].type, meta[k].flags);
-            print_data(meta[k].data.data_val, meta[k].data.data_len);
+        	if (meta[k].type != METADATA_BLOCK) {
+        		printf("Metadata block %d is not of type METADATA_BLOCK (%d)\n",
+        				meta[k].type, METADATA_BLOCK);
+        	} else {
+        		printf("Metadata Extension Block %i:\n", k);
+        	}
+            ret = sdnv_decode((u_char *)meta[k].data.data_val, meta[k].data.data_len, &ontology);
+            if (ret <= 0) {
+            	printf("Unable to decode metadata ontology\n");
+            	ret = 0;
+            	ontology = 0;
+            }
+            printf("\tontology = %i\n\tflags = %i\n\tmetadata length %i\n",
+                   (int)ontology, meta[k].flags, meta[k].data.data_len - ret);
+            print_data(meta[k].data.data_val + ret, meta[k].data.data_len - ret);
         }
 
         printf("%d payload bytes from [%s]: transit time=%d ms\n",
diff -r 00bddbb095de -r 7d8695f45fe0 apps/dtnrecv/dtnrecv.c
--- a/apps/dtnrecv/dtnrecv.c	Fri Jan 04 17:01:21 2013 +0000
+++ b/apps/dtnrecv/dtnrecv.c	Mon Jan 07 23:33:49 2013 +0000
@@ -28,6 +28,7 @@
 #include <sys/stat.h>
 #include <fcntl.h>
 #include "dtn_api.h"
+#include "sdnv-c.h"
 
 #define BUFSIZE 16
 #define BLOCKSIZE 8192
@@ -399,6 +400,7 @@
     dtn_bundle_spec_t spec;
     dtn_bundle_payload_t payload;
     int call_bind;
+    u_int64_t ontology;
 
     // force stdout to always be line buffered, even if output is
     // redirected to a pipe or file
@@ -571,15 +573,15 @@
             continue;
         }
 
-        printf("bundle spec at 0x%08X\n", &spec);
+        printf("bundle spec at %p\n", &spec);
 
         printf("\n%d extension blocks from [%s]: transit time=%d ms\n",
                spec.blocks.blocks_len, spec.source.uri, 0);
         dtn_extension_block_t *block = spec.blocks.blocks_val;
         for (k = 0; k < spec.blocks.blocks_len; k++) {
             printf("Extension Block %i:\n", k);
-            printf("\ttype = %i\n\tflags = %i\n",
-                   block[k].type, block[k].flags);
+            printf("\ttype = %i\n\tflags = %i\n\tdata length = %i\n",
+                   block[k].type, block[k].flags, block[k].data.data_len);
             print_data(block[k].data.data_val, block[k].data.data_len);
         }
 
@@ -587,12 +589,22 @@
                spec.metadata.metadata_len, spec.source.uri, 0);
         dtn_extension_block_t *meta = spec.metadata.metadata_val;
         for (k = 0; k < spec.metadata.metadata_len; k++) {
-            printf("Metadata Extension Block %i:\n", k);
-            printf("\ttype = %i\n\tflags = %i\n",
-                   meta[k].type, meta[k].flags);
-            print_data(meta[k].data.data_val, meta[k].data.data_len);
+        	if (meta[k].type != METADATA_BLOCK) {
+        		printf("Metadata block %d is not of type METADATA_BLOCK (%d)\n",
+        				meta[k].type, METADATA_BLOCK);
+        	} else {
+        		printf("Metadata Extension Block %i:\n", k);
+        	}
+            ret = sdnv_decode((u_char *)meta[k].data.data_val, meta[k].data.data_len, &ontology);
+            if (ret <= 0) {
+            	printf("Unable to decode metadata ontology\n");
+            	ret = 0;
+            	ontology = 0;
+            }
+            printf("\tontology = %i\n\tflags = %i\n\tmetadata length %i\n",
+                   (int)ontology, meta[k].flags, meta[k].data.data_len - ret);
+            print_data(meta[k].data.data_val + ret, meta[k].data.data_len - ret);
         }
-
         printf("%d payload bytes from [%s]: transit time=%d ms\n",
                payload.buf.buf_len,
                spec.source.uri, 0);
@@ -608,9 +620,9 @@
 
         dtn_free_payload(&payload);
         if (spec.blocks.blocks_len > 0) {
-        	int i=0;
+        	unsigned int i=0;
         	for ( i=0; i<spec.blocks.blocks_len; i++ ) {
-        		printf("Freeing extension block [%d].data at 0x%08X\n",
+        		printf("Freeing extension block [%d].data at %p\n",
         			   i, spec.blocks.blocks_val[i].data.data_val);
         	    free(spec.blocks.blocks_val[i].data.data_val);
         	}
@@ -619,9 +631,9 @@
             spec.blocks.blocks_len = 0;
         }
         if (spec.metadata.metadata_len > 0) {
-        	int i=0;
+        	unsigned int i=0;
         	for ( i=0; i<spec.metadata.metadata_len; i++ ) {
-        		printf("Freeing metadata block [%d].data at 0x%08X\n",
+        		printf("Freeing metadata block [%d].data at %p\n",
         			   i, spec.metadata.metadata_val[i].data.data_val);
         	    free(spec.metadata.metadata_val[i].data.data_val);
         	}
diff -r 00bddbb095de -r 7d8695f45fe0 apps/dtnsend/dtnsend.cc
--- a/apps/dtnsend/dtnsend.cc	Fri Jan 04 17:01:21 2013 +0000
+++ b/apps/dtnsend/dtnsend.cc	Mon Jan 07 23:33:49 2013 +0000
@@ -71,7 +71,7 @@
 char * data_source  = NULL;             // file or message, depending on type
 char date_buf[256];                     // buffer for date payloads
 
-// extension/metatdata block information
+// extension/metadata block information
 class ExtBlock {
 public:
     ExtBlock(u_int type = 0): metadata_(false), ontology_(0) {
@@ -317,7 +317,7 @@
 
     if (num_meta_blocks > 0) {
         void* buf = malloc(num_meta_blocks * sizeof(dtn_extension_block_t));
-        memset(buf, 0, num_ext_blocks * sizeof(dtn_extension_block_t));
+        memset(buf, 0, num_meta_blocks * sizeof(dtn_extension_block_t));
 
         dtn_extension_block_t * bp = (dtn_extension_block_t *)buf;
         for (unsigned int i = 0; i < ext_blocks.size(); ++i) {
diff -r 00bddbb095de -r 7d8695f45fe0 apps/dtnsource/dtnsource.cc
--- a/apps/dtnsource/dtnsource.cc	Fri Jan 04 17:01:21 2013 +0000
+++ b/apps/dtnsource/dtnsource.cc	Mon Jan 07 23:33:49 2013 +0000
@@ -38,6 +38,7 @@
 #include <vector>
 
 #include "dtn_api.h"
+#include "sdnv-c.h"
 
 char *progname;
 
@@ -57,14 +58,15 @@
 int delivery_options           = 0;    // bundle delivery option bit vector
 dtn_bundle_priority_t priority = COS_NORMAL; // bundle priority
 
-// extension/metatdata block information
+// extension/metadata block information
 class ExtBlock {
 public:
-    ExtBlock(u_int type = 0): metadata_(false) {
+    ExtBlock(u_int type = 0): metadata_(false), ontology_(0) {
         block_.type          = type;
         block_.flags         = 0;
         block_.data.data_len = 0;
         block_.data.data_val = NULL;
+        strcpy(ontology_buf_, "\0\0");
     }
     ~ExtBlock() {
         if (block_.data.data_val != NULL) {
@@ -77,6 +79,7 @@
     ExtBlock(const ExtBlock& o)
     {
         metadata_            = o.metadata_;
+        ontology_			 = o.ontology_;
         block_.type          = o.block_.type;
         block_.flags         = o.block_.flags;
         block_.data.data_len = o.block_.data.data_len;
@@ -86,7 +89,18 @@
     }
     
     bool        metadata() const { return metadata_; }
-    void        set_metadata()   { metadata_ = true; }
+    void        set_metadata(u_int64_t ontology)   {
+		if (ontology > ONTOLOGY_EXPT_MAX) {
+			fprintf(stderr, "Value of ontology greater than maximum allowed\n");
+			exit(1);
+		}
+		if (sdnv_encode(ontology, (u_char*)ontology_buf_, 3) < 0) {
+			fprintf(stderr, "SDNV encoding of ontology failed");
+			exit(1);
+		}
+		metadata_ = true;
+		ontology_ = ontology;
+	}
 
     dtn_extension_block_t & block() { return block_; }
     void set_block_buf(char * buf, u_int len) {
@@ -95,17 +109,26 @@
             block_.data.data_val = NULL;
             block_.data.data_len = 0;
         }
-        block_.data.data_val = buf;
-        block_.data.data_len = len;
+        if (metadata_) {
+        	block_.data.data_val = (char *)malloc(sizeof(char) * (len + strlen(ontology_buf_) + 1));
+        	block_.data.data_len = len + strlen(ontology_buf_);
+        	strcpy(block_.data.data_val, ontology_buf_);
+        	strncat(block_.data.data_val, buf, len);
+        	free(buf);
+        } else {
+			block_.data.data_val = buf;
+			block_.data.data_len = len;
+        }
     }
 
     static unsigned int   num_meta_blocks_;
 
 private:
     bool                  metadata_;
+    u_int64_t			  ontology_;
+    char            	  ontology_buf_[3];
     dtn_extension_block_t block_;
 };
-
 unsigned int ExtBlock::num_meta_blocks_ = 0;
 
 std::vector<ExtBlock> ext_blocks;
@@ -114,7 +137,7 @@
 char * arg_replyto      = NULL;
 char * arg_source       = NULL;
 char * arg_dest         = NULL;
-unsigned int arg_bundlesize = 0;
+unsigned int arg_bundlesize = 1;
 
 char *payload_buf       = NULL;
 
@@ -143,6 +166,7 @@
     dtn_bundle_payload_t reply_payload;
     struct timeval start, end;
     time_t now;
+    u_int32_t pi;
     
     // force stdout to always be line buffered, even if output is
     // redirected to a pipe or file
@@ -154,7 +178,7 @@
     payload_buf = (char *)malloc(sizeof(uint32_t) + arg_bundlesize);
     if (payload_buf == NULL) {
     
-	fprintf(stderr, "can't allocate %lu bytes for payload\n", 
+	fprintf(stderr, "can't allocate %u bytes for payload\n",
 		sizeof(uint32_t) + arg_bundlesize);
 	exit(1);
     }
@@ -274,10 +298,15 @@
     for (i = 1; i <= num_bundles; ++i) {
         gettimeofday(&start, NULL);
 
-	// put bundle number in first int
-	*(uint32_t *)payload_buf = htonl(i);
+		// put bundle number in first int or last byte if shorter than sizeof(int)
+		pi = i;
+		if (arg_bundlesize < sizeof(u_int32_t)){
+			pi <<= ((sizeof(u_int32_t) - arg_bundlesize) * 8);
+		}
+		*(uint32_t *)payload_buf = htonl(pi);
 
-	memset(payload_buf + sizeof(uint32_t), ((unsigned char)i & 0xff), arg_bundlesize);
+		memset(payload_buf + sizeof(u_int32_t), ((unsigned char)i & 0xff),
+			   arg_bundlesize);
 
         fill_payload(&send_payload);
         
@@ -376,7 +405,7 @@
     fprintf(stderr, " -W set the do not fragment option\n");
     fprintf(stderr, " -w wait for bundle status reports\n");
     fprintf(stderr, " -E <int> include extension block and specify type\n");
-    fprintf(stderr, " -M <int> include metadata block and specify type\n");
+    fprintf(stderr, " -M <int> include metadata block (type 8) and specify ontology for block\n");
     fprintf(stderr, " -O <int> flags to include in extension/metadata block\n");
     fprintf(stderr, " -S <string> extension/metadata block content\n");
     exit(1);
@@ -385,9 +414,14 @@
 void parse_options(int argc, char**argv)
 {
     int c, done = 0;
+    bool flags_set, data_set;
+    u_int64_t ontology;
 
     progname = argv[0];
 
+    flags_set = false;
+    data_set = false;
+
     while (!done)
     {
         c = getopt(argc, argv, "A:B:vhs:d:b:Hr:e:P:n:woDXFRcC1NWi:z:E:M:O:S:");
@@ -478,21 +512,44 @@
             break;
         case 'E':
             ext_blocks.push_back(ExtBlock(atoi(optarg)));
+            flags_set = false;
+            data_set = false;
             break;
         case 'M':
-            ext_blocks.push_back(ExtBlock(atoi(optarg)));
-            ext_blocks.back().set_metadata();
+        	ontology = atoi(optarg);
+        	if (!((ontology == ONTOLOGY_URI) ||
+        		  ((ontology >= ONTOLOGY_EXPT_MIN) &&
+        		   (ontology <= ONTOLOGY_EXPT_MAX)))) {
+        		fprintf(stderr, "-M - ontology type is not in use - available 1, 192-255\n");
+        		exit(1);
+        	}
+            ext_blocks.push_back(ExtBlock(METADATA_BLOCK));
+            ext_blocks.back().set_metadata(ontology);
             ExtBlock::num_meta_blocks_++;
+            flags_set = false;
+            data_set = false;
             break;
         case 'O':
-            if (ext_blocks.size() > 0) {
+            if ((ext_blocks.size() > 0) && !flags_set) {
                 ext_blocks.back().block().flags = atoi(optarg);
+                flags_set = true;
+            } else if (flags_set) {
+            	fprintf(stderr, "Ignoring duplicate flag setting\n");
+            } else {
+            	fprintf(stderr, "No extension or metadata block defined to receive flags\n");
+            	exit(1);
             }
             break;
         case 'S':
-            if (ext_blocks.size() > 0) {
+            if ((ext_blocks.size() > 0) && !data_set) {
                 char * block_buf = strdup(optarg);
                 ext_blocks.back().set_block_buf(block_buf, strlen(block_buf));
+                data_set = true;
+            } else if (data_set) {
+            	fprintf(stderr, "Ignoring duplicate data setting\n");
+            } else {
+            	fprintf(stderr, "No extension or metadata block defined to receive data\n");
+            	exit(1);
             }
             break;
         case -1:
@@ -506,9 +563,18 @@
         }
     }
 
-    if (arg_source == 0 || arg_dest == 0 || arg_bundlesize == 0) {
-	print_usage();
-	exit(1);
+    if (arg_source == NULL || arg_dest == NULL || arg_bundlesize == 0) {
+    	if (arg_source == NULL) {
+    		fprintf(stderr, "Must provide source EID (-s)\n");
+    	}
+    	if (arg_dest == NULL) {
+    		fprintf(stderr, "Must provide destination EID (-d)\n");
+    	}
+    	if (arg_bundlesize == 0) {
+    		fprintf(stderr, "Bundle payload size must be > 0 (-b)\n");
+    	}
+    	print_usage();
+    	exit(1);
     }
 }
 
diff -r 00bddbb095de -r 7d8695f45fe0 servlib/bundling/MetadataBlock.cc
--- a/servlib/bundling/MetadataBlock.cc	Fri Jan 04 17:01:21 2013 +0000
+++ b/servlib/bundling/MetadataBlock.cc	Mon Jan 07 23:33:49 2013 +0000
@@ -73,7 +73,7 @@
     ontology_(copy.ontology_), metadata_(NULL),
     metadata_len_(0)
 {
-    if (copy.generated_ && (copy.metadata_len_ > 0)) {
+    if (copy.metadata_len_ > 0) {
         ASSERT(copy.metadata_ != NULL);
         metadata_ = new u_char[copy.metadata_len_];
         memcpy(metadata_, copy.metadata_, copy.metadata_len_);
@@ -89,7 +89,7 @@
 MetadataBlock::~MetadataBlock()
 {
     outgoing_metadata_.clear();
-    if (generated_ && (metadata_ != NULL)) {
+    if (metadata_ != NULL) {
         delete[] metadata_;
         metadata_ = NULL;
         metadata_len_ = 0;
@@ -112,7 +112,11 @@
 
     if (len > 0) {
         ASSERT(buf != NULL);
-        metadata_ = buf;
+        if (metadata_ != NULL) {
+        	delete[] metadata_;
+        }
+        metadata_ = new u_char[len];
+        memcpy(metadata_, buf, len);
         metadata_len_ = len;
     } else {
         metadata_ = NULL;
@@ -213,7 +217,7 @@
     }
 
     outgoing_metadata_.clear();
-    if (generated_ && (metadata_ != NULL)) {
+    if (metadata_ != NULL) {
         delete[] metadata_;
         metadata_ = NULL;
         metadata_len_ = 0;
@@ -225,7 +229,7 @@
     error_     = copy.error_;
     ontology_  = copy.ontology_;
 
-    if (copy.generated_ && (copy.metadata_len_ > 0)) {
+    if (copy.metadata_len_ > 0) {
         ASSERT(copy.metadata_ != NULL);
         metadata_ = new u_char[copy.metadata_len_];
         memcpy(metadata_, copy.metadata_, copy.metadata_len_);
diff -r 00bddbb095de -r 7d8695f45fe0 servlib/bundling/MetadataBlockProcessor.cc
--- a/servlib/bundling/MetadataBlockProcessor.cc	Fri Jan 04 17:01:21 2013 +0000
+++ b/servlib/bundling/MetadataBlockProcessor.cc	Mon Jan 07 23:33:49 2013 +0000
@@ -289,8 +289,8 @@
         
         // If it is modified, len and buf were set by metadata_modified().
 
-        block_data_len = SDNV::encoding_len(metadata->ontology()) +
-                         SDNV::encoding_len(len) + len;
+        block_data_len = SDNV::encoding_len(metadata->ontology()) + len;
+                         //SDNV::encoding_len(len) + len;  // Old code - doesn't match spec
     }
 
     // Determine the preamble flags for the outgoing metadata block.
@@ -308,9 +308,10 @@
 
     // Generate the generic block preamble and reserve
     // buffer space for the block-specific data.
-    generate_preamble(xmit_blocks, block, block_type(), flags, block_data_len);
-    //block->writable_contents()->reserve(block->data_offset() + block_data_len);
-    block->writable_contents()->reserve(block->data_offset() + block_data_len+100);
+    generate_preamble(xmit_blocks, block, BundleProtocol::METADATA_BLOCK,
+    		          flags, block_data_len);
+    block->writable_contents()->reserve(block->data_offset() + block_data_len);
+    //block->writable_contents()->reserve(block->data_offset() + block_data_len+100);
     block->writable_contents()->set_len(block->data_offset() + block_data_len);
 
     // Simply copy the incoming metadata to the outgoing buffer
@@ -319,7 +320,7 @@
     if (received_block && !modified) {
         memcpy(block->writable_contents()->buf() + block->data_offset(),
                block->source()->contents().buf() + block->data_offset(),
-               block->data_length());
+               block_data_len);
         return BP_SUCCESS;
     }
 
@@ -335,11 +336,13 @@
     outgoing_buf += sdnv_len;
     outgoing_len -= sdnv_len;
 
+#if 0
     // Write the ontology data length.
     sdnv_len = SDNV::encode(len, outgoing_buf, outgoing_len);
     ASSERT(sdnv_len > 0);
     outgoing_buf += sdnv_len;
     outgoing_len -= sdnv_len;
+#endif
 
     // Write the ontology data.
     ASSERT(block->contents().nfree() >= len);
@@ -372,10 +375,13 @@
     u_char *  buf = block->data();
     u_int32_t len = block->data_length();
 
+#if 0
     char buf2[2000];
     for (u_int32_t i = 0; i <len; i++)
     	sprintf(&buf2[2*i], "%02x", buf[i]);
+    buf2[len] = '\0';
     log_info_p(log, "Buf: %s Len: %d", buf2, len);
+#endif
 
    // Read the metadata block ontology.
     int ontology_len = 0;
diff -r 52e2b403edd4 -r 00bddbb095de applib/APIServer.cc
--- a/applib/APIServer.cc	Mon Nov 19 11:58:18 2012 +0000
+++ b/applib/APIServer.cc	Fri Jan 04 17:01:21 2013 +0000
@@ -1087,6 +1087,7 @@
             init_block(info,
 					   b->api_blocks(),
 					   b.object(),
+					   BlockProcessor::transfer_src_ts(),
                        block->type,
                        block->flags,
                        (u_char*)block->data.data_val,
@@ -1098,54 +1099,69 @@
     for (unsigned int i = 0; i < spec.metadata.metadata_len; ++i) {
         dtn_extension_block_t* block = &spec.metadata.metadata_val[i];
 
+#if 0
+        // XXX/Elwyn - this is just plain wrong!  This puts the RFC5050 block
+        // type in the ontology slot for the MetadataBlock (partly due to the
+        // naming of the parameter on the constructor - now altered).
+        MetadataBlock * meta_block = new MetadataBlock(
+                                             (u_int64_t)block->type,
+                                             (u_char *)block->data.data_val,
+                                             (u_int32_t)block->data.data_len);
+        meta_block->set_flags((u_int64_t)block->flags);
+
+        b->mutable_recv_metadata()->push_back(meta_block);
+#endif
+
+        // XXX/kscott This has to get put somewhere where it will be serialized
+        // so that if it is delivered locally, it'll be available after a restart.
+        // Need to prepend the metadata type SDNV (block->type) to the actual
+        // content of the BlockInfo (difference between BlockInfo and MetadataBlock)
+        // XXX/elwynd The business about prepending the type is not true.
+        //{
+        //u_char temp[block->data.data_len+20];
+        //int curPos = 0;
+
+        BlockProcessor *owner =
+            BundleProtocol::find_processor(BundleProtocol::METADATA_BLOCK);
+        BlockInfo* info =
+            b->api_blocks()->append_block(owner);
+        //curPos += SDNV::encode(block->type, &(temp[curPos]), 1024);
+        //curPos += SDNV::encode(block->data.data_len, &(temp[curPos]), 1024);
+        //memcpy(&(temp[curPos]),
+        //       (u_char*)block->data.data_val, block->data.data_len);
+
+        owner->
+            init_block(info,
+            		   b->api_blocks(),
+            		   b.object(),
+            		   0, // No transfer flags
+            		   BundleProtocol::METADATA_BLOCK,
+            		   block->flags,
+                       (u_char *)block->data.data_val,
+                       block->data.data_len);
+        // info->set_complete(true);
+
+#if 0
+		// XXX/Elwyn - leaving this extra code in means that there are now
+        // two identical metadata blocks connected to the bundle
+        // and these both get sent to at least local receipients.
+        // This is not correct and with the previous (changeset 3550) changes
+        // that send the api_blocks to local recipients, there is no need for this
+        // fudge.  Taking it out for the time being until somebody says it is wrong.
+        // XXX/demmer currently this block needs to be stuck on the
+        // outgoing metadata for the null link (so it's transmit to
+        // all destinations) as well as on the recv_metadata vector so
+        // it's conveyed to local applications. this should really be
+        // cleaned up...
         LinkRef null_link("APIServer::handle_send");
         MetadataVec * vec = b->generated_metadata().find_blocks(null_link);
         if (vec == NULL) {
             vec = b->mutable_generated_metadata()->create_blocks(null_link);
         }
         ASSERT(vec != NULL);
-
-        MetadataBlock * meta_block = new MetadataBlock(
-                                             (u_int64_t)block->type,
-                                             (u_char *)block->data.data_val,
-                                             (u_int32_t)block->data.data_len);
-        meta_block->set_flags((u_int64_t)block->flags);
-
-        // XXX/demmer currently this block needs to be stuck on the
-        // outgoing metadata for the null link (so it's transmit to
-        // all destinations) as well as on the recv_metadata vector so
-        // it's conveyed to local applications. this should really be
-        // cleaned up...
-        vec->push_back(meta_block);
-        b->mutable_recv_metadata()->push_back(meta_block);
-
-        // XXX/kscott This has to get put somewhere where it will be serialized
-        // so that if it is delivered locally, it'll be available after a restart.
-        // Need to prepend the metadata type SDNV (block->type) to the actual
-        // content of the BlockInfo (difference between BlockInfo and MetadataBlock)
-        {
-        u_char temp[block->data.data_len+20];
-        int curPos = 0;
-
-        BlockProcessor *owner =
-            BundleProtocol::find_processor(BundleProtocol::METADATA_BLOCK);
-        BlockInfo* info =
-            b->api_blocks()->append_block(owner);
-        curPos += SDNV::encode(block->type, &(temp[curPos]), 1024);
-        curPos += SDNV::encode(block->data.data_len, &(temp[curPos]), 1024);
-        memcpy(&(temp[curPos]),
-               (u_char*)block->data.data_val, block->data.data_len);
-
-        APIBlockProcessor::instance()->
-            init_block(info,
-            		   b->api_blocks(),
-            		   b.object(),
-            		   BundleProtocol::METADATA_BLOCK,
-            		   block->flags,
-                       temp,
-                       curPos+block->data.data_len);
-        info->set_complete(true);
-        }
+        vec->push_back(dynamic_cast<MetadataBlock *>(info->locals()));
+        //}
+#endif
     }
 
     // validate the bundle metadata
diff -r 52e2b403edd4 -r 00bddbb095de applib/Makefile
--- a/applib/Makefile	Mon Nov 19 11:58:18 2012 +0000
+++ b/applib/Makefile	Fri Jan 04 17:01:21 2013 +0000
@@ -28,6 +28,9 @@
 		dtn_errno.c		\
 		dtn_ipc.c		\
 		sdnv-c.c		\
+		bpq_api.c       \
+		json.c			\
+		mkrandstr.c		\
 
 # Sources for the client-side library that depend on liboasys
 CLIENT_EXTRA_SRCS :=			\
diff -r 52e2b403edd4 -r 00bddbb095de applib/bpq_api.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/applib/bpq_api.c	Fri Jan 04 17:01:21 2013 +0000
@@ -0,0 +1,849 @@
+/*
+ *    Copyright 2012 Trinity College Dublin
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include <dtn-config.h>
+#endif
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#include "dtn_api.h"
+#include "sdnv-c.h"
+#include "bpq_api.h"
+#include "json.h"
+
+#define BLOCKSIZE 8192
+
+
+/*******************************************************************************
+* parse eid:
+*
+* code lifted from dtnsend
+*******************************************************************************/
+dtn_endpoint_id_t *
+parse_eid(dtn_handle_t handle,
+    dtn_endpoint_id_t * eid,
+    const char * str,
+    int verbose)
+{
+    // try the string as an actual dtn eid
+    if (dtn_parse_eid_string(eid, str) == DTN_SUCCESS) {
+        if (verbose) fprintf(stdout, "%s (literal)\n", str);
+        return eid;
+    }
+
+    // build a local eid based on the configuration of our dtn
+    // router plus the str as demux string
+    else if (dtn_build_local_eid(handle, eid, str) == DTN_SUCCESS) {
+        if (verbose) fprintf(stdout, "%s (local)\n", str);
+        return eid;
+    }
+    else {
+        fprintf(stderr, "invalid eid string '%s'\n", str);
+        exit(1);
+    }
+}
+
+
+/*******************************************************************************
+* bpq to char array
+* encode the following information:
+*
+*   BPQ-kind             		1-byte
+*   Matching rule 				1-byte
+*
+*   Creation time-stamp	sec		SDNV
+*   Creation time-stamp	seq		SDNV
+*   Source EID length			SDNV
+*   Source EID 					n-bytes
+*
+*   Query ID length     		SDNV
+*   Query ID            		n-bytes
+*
+*   Query value length     		SDNV
+*   Query value            		n-bytes
+*
+*   Number of fragments  		SDNV
+*   Fragment offsets    		SDNV
+*   Fragment lengths     		SDNV
+*
+* @return The number of bytes or -1 on error
+*******************************************************************************/
+int
+bpq_to_char_array(const dtn_bpq_extension_block_data_t * bpq,
+    char* buf,
+    size_t buf_len,
+    int verbose)
+{
+    int j=0, i_encoding_len, q_encoding_len, f_encoding_len, encoding_len;
+    u_int i=0, k=0;
+    u_char encoding[PATH_MAX];
+
+    memset(buf, 0, buf_len);
+
+    // BPQ-kind             1-byte
+    if (i < buf_len)    buf[i++] = (char) bpq->kind;
+
+    // matching rule type   1-byte
+    if (i < buf_len)    buf[i++] = (char) bpq->matching_rule;
+
+    // Timestamp secs (SDNV)
+	if ( (q_encoding_len = sdnv_encode (bpq->original_id.creation_ts.secs,
+										encoding, PATH_MAX)) == -1 ) {
+		fprintf (stderr, "Error encoding creation timestamp secs\n");
+		return -1;
+	} else {
+		for (j=0; i<buf_len && j<q_encoding_len; ++j)
+	        buf[i++] = encoding[j];
+	}
+
+    // Timestamp seqno (SDNV)
+	if ( (q_encoding_len = sdnv_encode (bpq->original_id.creation_ts.seqno,
+										encoding, PATH_MAX)) == -1 ) {
+		fprintf (stderr, "Error encoding creation timestamp seqno\n");
+		return -1;
+	} else {
+		for (j=0; i<buf_len && j<q_encoding_len; ++j)
+	        buf[i++] = encoding[j];
+	}
+
+    // Source EID len (SDNV)
+	if ( (q_encoding_len = sdnv_encode (bpq->original_id.source_len,
+										encoding, PATH_MAX)) == -1 ) {
+		fprintf (stderr, "Error encoding source EID len\n");
+		return -1;
+	} else {
+		for (j=0; i<buf_len && j<q_encoding_len; ++j)
+	        buf[i++] = encoding[j];
+	}
+
+    // Source EID n-bytes
+	 if ( (i + bpq->original_id.source_len) < buf_len ) {
+		memcpy(&(buf[i]), bpq->original_id.source.uri, bpq->original_id.source_len);
+		i += bpq->original_id.source_len;
+	} else {
+		fprintf (stderr, "Error encoding Source EID value\n");
+		return -1;
+	}
+
+
+	// Query ID length (SDNV)
+	if ( (i_encoding_len = sdnv_encode (bpq->query_id.query_id_len,
+										encoding, PATH_MAX)) == -1 ) {
+		fprintf (stderr, "Error encoding query ID len\n");
+		return -1;
+	} else {
+		for (j=0; i<buf_len && j<i_encoding_len; ++j)
+			buf[i++] = encoding[j];
+	}
+
+	// Query ID n-bytes
+	if ( (i + bpq->query_id.query_id_len) < buf_len ) {
+		memcpy(&(buf[i]), bpq->query_id.query_id_val, bpq->query_id.query_id_len);
+		i += bpq->query_id.query_id_len;
+	} else {
+		fprintf (stderr, "Error encoding query ID value\n");
+		return -1;
+	}
+
+
+	// Query length (SDNV)
+	if ( (q_encoding_len = sdnv_encode (bpq->query.query_len,
+										encoding, PATH_MAX)) == -1 ) {
+		fprintf (stderr, "Error encoding query len\n");
+		return -1;
+	} else {
+		for (j=0; i<buf_len && j<q_encoding_len; ++j)
+			buf[i++] = encoding[j];
+	}
+
+	// Query value n-bytes
+	if ( (i + bpq->query.query_len) < buf_len ) {
+		memcpy(&(buf[i]), bpq->query.query_val, bpq->query.query_len);
+		i += bpq->query.query_len;
+	} else {
+		fprintf (stderr, "Error encoding query value\n");
+		return -1;
+	}
+
+
+    // number of fragments  SDNV
+    if ( (f_encoding_len = sdnv_encode (bpq->fragments.num_frag_returned,
+    									encoding, PATH_MAX)) == -1 ){
+    	fprintf (stderr, "Error encoding number of fragments\n");
+        return -1;
+    } else {
+    	for (j=0; i<buf_len && j<f_encoding_len; ++j)
+    		buf[i++] = encoding[j];
+    }
+
+    for (k=0; k<bpq->fragments.num_frag_returned; ++k) {
+
+        // fragment offsets     SDNV
+        if ( (encoding_len = sdnv_encode (bpq->fragments.frag_offsets[k],
+        								  encoding, PATH_MAX)) == -1 ) {
+        	fprintf (stderr, "Error encoding fragment offset[%d]\n", k);
+        	return -1;
+        } else {
+        	for (j=0; i<buf_len && j<encoding_len; ++j)
+        		buf[i++] = encoding[j];
+        }
+
+        // fragment lengths     SDNV
+        if ( (encoding_len = sdnv_encode (bpq->fragments.frag_lenghts[k],
+        								  encoding, PATH_MAX)) == -1 ) {
+        	fprintf (stderr, "Error encoding fragment length[%d]\n", k);
+        	return -1;
+        } else {
+        	for (j=0; i<buf_len && j<encoding_len; ++j)
+        		buf[i++] = encoding[j];
+        }
+    }
+
+    if (verbose) {
+        fprintf (stdout, "\nbpq_to_char_array (buf_len:%d, i:%d):\n",buf_len,i);
+        fprintf (stdout, "             kind: %d\n", (int) buf[0]);
+        fprintf (stdout, "    matching rule: %d\n", (int) buf[1]);
+
+        fprintf (stdout, "  creation ts sec: %d\n",
+        		 (int) bpq->original_id.creation_ts.secs);
+        fprintf (stdout, "  creation ts seq: %d\n",
+        		 (int) bpq->original_id.creation_ts.seqno);
+        fprintf (stdout, "   source eid len: %d\n",
+        		 (int) bpq->original_id.source_len);
+        fprintf (stdout, "       source eid: %s\n",
+        		       bpq->original_id.source.uri);
+
+        fprintf (stdout, "     query ID len: %d\n", bpq->query_id.query_id_len);
+        fprintf (stdout, "   i_encoding_len: %d\n", i_encoding_len);
+        fprintf (stdout, "         query ID: %s\n", bpq->query_id.query_id_val);
+
+        fprintf (stdout, "        query len: %d\n", bpq->query.query_len);
+        fprintf (stdout, "   q_encoding_len: %d\n", q_encoding_len);
+        fprintf (stdout, "        query val: %s\n", bpq->query.query_val);
+
+        fprintf (stdout, "     fragment len: %d\n", bpq->fragments.num_frag_returned);
+        fprintf (stdout, "   f_encoding_len: %d\n\n", f_encoding_len);
+    }
+
+    return i;
+}
+
+/*******************************************************************************
+* char array to bpq
+* decode the following information:
+*
+*   BPQ-kind             		1-byte
+*   Matching rule 				1-byte
+*
+*   Creation time-stamp	sec		SDNV
+*   Creation time-stamp	seq		SDNV
+*   Source EID length			SDNV
+*   Source EID 					n-bytes
+*
+*   Query ID length     		SDNV
+*   Query ID            		n-bytes
+*
+*   Query value length     		SDNV
+*   Query value            		n-bytes
+*
+*   Number of fragments  		SDNV
+*   Fragment offsets    		SDNV
+*   Fragment lengths     		SDNV
+*
+* @return The number of bytes or -1 on error
+*******************************************************************************/
+int
+char_array_to_bpq(const u_char* buf,
+    size_t buf_len,
+    dtn_bpq_extension_block_data_t * bpq,
+    int verbose)
+{
+    u_int i=0, j=0;
+    int q_decoding_len, f_decoding_len, i_decoding_len, decoding_len;
+
+    // BPQ-kind             1-byte
+    if (i<buf_len) bpq->kind = (u_int) buf[i++];
+
+    // matching rule type   1-byte
+    if (i<buf_len) bpq->matching_rule = (u_int) buf[i++];
+
+
+
+    // Creation time-stamp sec     SDNV
+    if ( (q_decoding_len = sdnv_decode (&(buf[i]),
+    									buf_len - i,
+    									&(bpq->original_id.creation_ts.secs))) == -1 ) {
+        fprintf (stderr, "Error decoding creation time-stamp sec\n");
+        return -1;
+    }
+    i += q_decoding_len;
+
+    // Creation time-stamp seq     SDNV
+    if ( (q_decoding_len = sdnv_decode (&(buf[i]),
+    									buf_len - i,
+    									&(bpq->original_id.creation_ts.seqno))) == -1 ) {
+        fprintf (stderr, "Error decoding creation time-stamp seq\n");
+        return -1;
+    }
+    i += q_decoding_len;
+
+    // Source EID length     SDNV
+    if ( (q_decoding_len = sdnv_decode (&(buf[i]),
+    									buf_len - i,
+    									(u_int64_t*)&(bpq->original_id.source_len))) == -1 ) {
+        fprintf (stderr, "Error decoding source EID length\n");
+        return -1;
+    }
+    i += q_decoding_len;
+
+    // Source EID            n-bytes
+    if (i<buf_len && bpq->original_id.source_len <= DTN_MAX_ENDPOINT_ID) {
+    	strncpy(bpq->original_id.source.uri, (char*)&(buf[i]), bpq->original_id.source_len);
+    	i += bpq->original_id.source_len;
+    } else {
+    	fprintf (stderr, "Error copying source EID\n");
+		return -1;
+    }
+
+    // BPQ-ID-length        SDNV
+    if ( (i_decoding_len = sdnv_decode (&(buf[i]),
+    									buf_len - i,
+    									(u_int64_t*)&(bpq->query_id.query_id_len))) == -1 ) {
+        fprintf (stderr, "Error decoding BPQ-ID-length\n");
+        return -1;
+    }
+    i += i_decoding_len;
+
+    // BPQ-ID               n-bytes
+    if (i<buf_len) bpq->query_id.query_id_val = (char*)&(buf[i]);
+    	i += bpq->query_id.query_id_len;
+
+
+    // BPQ-value-length     SDNV
+    if ( (q_decoding_len = sdnv_decode (&(buf[i]),
+    									buf_len - i,
+    									(u_int64_t*)&(bpq->query.query_len))) == -1 ) {
+        fprintf (stderr, "Error decoding BPQ-value-length\n");
+        return -1;
+    }
+    i += q_decoding_len;
+
+    // BPQ-value            n-bytes
+    if (i<buf_len) bpq->query.query_val = (char*)&(buf[i]);
+    	i += bpq->query.query_len;
+
+
+    // number of fragments  SDNV
+    if ( (f_decoding_len = sdnv_decode (&(buf[i]),
+    									buf_len - i,
+    									(u_int64_t*)&(bpq->fragments.num_frag_returned))) == -1 ) {
+        fprintf (stderr, "Error decoding number of fragments\n");
+        return -1;
+    }
+    i += f_decoding_len;
+
+    for (j=0; i<buf_len && j<bpq->fragments.num_frag_returned; ++j) {
+
+        // fragment offsets     SDNV
+        if ( (decoding_len = sdnv_decode (&(buf[i]),
+        								  buf_len - i,
+        								  (u_int64_t*)&(bpq->fragments.frag_offsets[j]))) == -1 ) {
+            fprintf (stderr, "Error decoding fragment[%d] offset\n", j);
+            return -1;
+        }
+        i += decoding_len;
+
+        // fragment lengths     SDNV
+        if ( (decoding_len = sdnv_decode (&(buf[i]),
+        								  buf_len - i,
+        								  (u_int64_t*)&(bpq->fragments.frag_lenghts[j]))) == -1 ) {
+            fprintf (stderr, "Error decoding fragment[%d] length\n", j);
+            return -1;
+        }
+        i += decoding_len;
+    }
+
+    if (i != buf_len)
+        return -1;
+
+    if (verbose) {
+        fprintf (stdout, "\nchar_array_to_bpq (buf_len:%d, i:%d):\n",buf_len, i);
+        fprintf (stdout, "             kind: %d\n", (int) buf[0]);
+        fprintf (stdout, "    matching rule: %d\n", (int) buf[1]);
+
+        fprintf (stdout, "  creation ts sec: %d\n",
+        		 (int) bpq->original_id.creation_ts.secs);
+        fprintf (stdout, "  creation ts seq: %d\n",
+        		 (int) bpq->original_id.creation_ts.seqno);
+        fprintf (stdout, "   source eid len: %d\n",
+        		 (int) bpq->original_id.source_len);
+        fprintf (stdout, "       source eid: %s\n",
+        		 bpq->original_id.source.uri);
+
+        fprintf (stdout, "     query ID len: %d\n", bpq->query_id.query_id_len);
+        fprintf (stdout, "   i_decoding_len: %d\n", i_decoding_len);
+        fprintf (stdout, "     query ID val: %s\n", bpq->query_id.query_id_val);
+
+       fprintf (stdout, "        query len: %d\n", bpq->query.query_len);
+        fprintf (stdout, "   q_decoding_len: %d\n", q_decoding_len);
+        fprintf (stdout, "        query val: %s\n", bpq->query.query_val);
+
+        fprintf (stdout, "     fragment len: %d\n", bpq->fragments.num_frag_returned);
+        fprintf (stdout, "   f_decoding_len: %d\n\n", f_decoding_len);
+    }
+
+    return DTN_SUCCESS;
+}
+
+/*******************************************************************************
+* handle file transfer:
+* copy the received payload file to the destination file
+* @return 0 on success or -1 on error
+*******************************************************************************/
+int
+handle_file_transfer(dtn_bundle_spec_t bundle_spec,
+    dtn_bundle_payload_t payload,
+    const char * destination,
+    int verbose)
+{
+
+    int src_fd;
+    int dest_fd;
+    char block[BLOCKSIZE];
+    ssize_t bytes_read;
+    struct stat fileinfo;
+
+    // Try a rename first - will fail if
+
+    if ( (src_fd = open(payload.filename.filename_val, O_RDONLY)) < 0) {
+        fprintf(stderr, "error opening payload file for reading '%s': %s\n",
+                payload.filename.filename_val, strerror(errno));
+        return -1;
+    }
+
+    if ( (dest_fd = creat(destination, 0644)) < 0) {
+        fprintf(stderr, "error opening output file for writing '%s': %s\n",
+                destination, strerror(errno));
+        close(src_fd);
+        return -1;
+    }
+
+
+    // Duplicate the file
+    while ( (bytes_read = read(src_fd, block, BLOCKSIZE)) > 0 )
+        write(dest_fd, block, bytes_read);
+
+    close(src_fd);
+    close(dest_fd);
+
+    unlink(payload.filename.filename_val);
+
+    if ( stat(destination, &fileinfo) == -1 ) {
+        fprintf(stderr, "Unable to stat destination file '%s': %s\n",
+                destination, strerror(errno));
+        return -1;
+    }
+
+    if (verbose) printf("%d byte file from [%s]: transit time=%d ms, written to '%s'\n",
+           (int)fileinfo.st_size, bundle_spec.source.uri, 0, destination);
+
+    return DTN_SUCCESS;
+}
+/*******************************************************************************
+* send bpq:
+* build a bundle with a BPQ extension block containing the name to be associated
+* with the file given as a payload and send it to the destination (which may be
+* totally arbitrary - the intention is to publish the file and have it cached
+* where it passes.
+*******************************************************************************/
+int
+send_bpq(dtn_handle_t handle,
+	const dtn_bpq_extension_block_kind_t kind,
+	const dtn_endpoint_id_t * src_eid,
+    const dtn_endpoint_id_t * dest_eid,
+    const dtn_endpoint_id_t * reply_eid,
+    char * query,
+    char * query_id,
+    char * metadata,
+    char * payload_file,
+    int matching_rule,
+    int bundle_expiry,
+    dtn_bundle_priority_t  priority,
+    int delivery_options,
+    int verbose)
+{
+    int  ret = 0, i;
+    int  enc_len;
+    char buf [PATH_MAX];
+    u_char mbuf [PATH_MAX];
+    size_t buf_len = 0;
+    dtn_bundle_id_t                 bundle_id;
+    dtn_bundle_spec_t               bundle_spec;
+    dtn_extension_block_t           bpq_block, metadata_block;
+    dtn_bpq_extension_block_data_t  bpq_block_data;
+    dtn_bundle_payload_t            payload;
+
+    memset(buf,             0, PATH_MAX);
+    memset(&bundle_spec,    0, sizeof(dtn_bundle_spec_t));
+    memset(&bpq_block,      0, sizeof(dtn_extension_block_t));
+    memset(&metadata_block, 0, sizeof(dtn_extension_block_t));
+    memset(&bpq_block_data, 0, sizeof(dtn_bpq_extension_block_data_t));
+    memset(&payload,        0, sizeof(dtn_bundle_payload_t));
+
+    // set the bpq block data
+    bpq_block_data.kind = kind;
+    bpq_block_data.matching_rule = matching_rule;
+
+    bpq_block_data.original_id.creation_ts.secs = 0;
+    bpq_block_data.original_id.creation_ts.seqno = 0;
+    bpq_block_data.original_id.source = *src_eid;
+    bpq_block_data.original_id.source_len = strlen(src_eid->uri);
+
+    bpq_block_data.query_id.query_id_len = strlen(query_id) + 1;     // include the null char at the end
+    bpq_block_data.query_id.query_id_val = query_id;
+
+    bpq_block_data.query.query_len = strlen(query) + 1;     // include the null char at the end
+    bpq_block_data.query.query_val = query;
+    bpq_block_data.fragments.num_frag_returned = 0;
+    bpq_block_data.fragments.frag_offsets = NULL;
+    bpq_block_data.fragments.frag_lenghts = NULL;
+
+    buf_len = bpq_to_char_array(&bpq_block_data, buf, PATH_MAX, verbose);
+
+    // set the bpq block
+    bpq_block.type = QUERY_EXTENSION_BLOCK;
+    bpq_block.flags = BLOCK_FLAG_REPLICATE;
+    bpq_block.data.data_len = buf_len;
+    bpq_block.data.data_val = buf;
+
+    /**
+     * If there is metadata supplied, add a metadata block to bundle
+     */
+    if (strlen(metadata) > 0){
+		// Put the ontology for the metadata st start of buffer
+        if ( (enc_len = sdnv_encode (JSON_METADATA_BLOCK, mbuf, PATH_MAX)) == -1 ) {
+        	fprintf (stderr, "Error encoding metadata ontology\n");
+        	return -1;
+        }
+
+        // Copy in the actual metadata
+        strncpy(&mbuf[enc_len], metadata, (PATH_MAX - enc_len));
+
+		// set the metadata block
+		metadata_block.type = METADATA_BLOCK;
+		metadata_block.flags = BLOCK_FLAG_REPLICATE;
+		metadata_block.data.data_len = enc_len + strlen(metadata) + 1;
+		metadata_block.data.data_val = mbuf;
+
+		for (i = 0; i < (enc_len + strlen(metadata) + 1); i++)
+			fprintf(stdout, "%02x", mbuf[i]);
+
+    	if (verbose) fprintf(stdout, "Metadata: %s (%d - %d); Type: %d\n",
+    			                     metadata, enc_len, enc_len + strlen(metadata) + 1,
+    			                     JSON_METADATA_BLOCK);
+    }
+
+    // set the payload (expected to be file path if not NULL)
+    if (payload_file != NULL) {
+    	dtn_set_payload(&payload, DTN_PAYLOAD_FILE, payload_file, strlen(payload_file));
+    } else {
+    	dtn_set_payload(&payload, DTN_PAYLOAD_MEM, NULL, 0);
+    }
+
+    // set the bundle spec eids
+    if (verbose) fprintf(stdout, "Source: %s\n", src_eid->uri);
+    if (verbose) fprintf(stdout, "Destination: %s\n", dest_eid->uri);
+    if (verbose) fprintf(stdout, "Reply-To: %s\n", reply_eid->uri);
+    bundle_spec.source = *src_eid;
+    bundle_spec.dest = *dest_eid;
+    bundle_spec.replyto = *reply_eid;
+
+    // set the bundle spec dtn options
+    bundle_spec.expiration = bundle_expiry;
+    bundle_spec.dopts = delivery_options;
+    bundle_spec.priority = priority;
+
+    // set the bundle extension
+    bundle_spec.blocks.blocks_len = 1;
+    bundle_spec.blocks.blocks_val = &bpq_block;
+
+    // set the bundle metadata if there is any (whole structure was zeroed initially)
+    if (strlen(metadata) > 0){
+    	bundle_spec.metadata.metadata_len = 1;
+    	bundle_spec.metadata.metadata_val = &metadata_block;
+    }
+
+    // send the bundle, bpq extension and empty payload
+    if (verbose) fprintf(stdout, "Sending bundle to: %s (options %x)\n",
+					     dest_eid->uri, delivery_options);
+    ret = dtn_send(handle, DTN_REGID_NONE, &bundle_spec, &payload, &bundle_id);
+    if (ret != DTN_SUCCESS) {
+        fprintf(stderr, "error sending bundle: %d (%s)\n",
+                    ret, dtn_strerror(dtn_errno(handle)));
+    } else if (verbose) {
+        fprintf(stdout, "bundle sent successfully: id %s,%llu.%llu\n",
+                    bundle_id.source.uri,
+                    bundle_id.creation_ts.secs,
+                    bundle_id.creation_ts.seqno);
+    }
+    return ret;
+}
+
+/*******************************************************************************
+* recv bpq:
+* given a registration handle, listen for count bundles.
+* if count is 0 - listen forever
+* as new bundles arrive save the payload as filename
+* (add _<n> if more than one bundle)
+* if filename is NULL, use the query value as the filename
+* if there is metadata in the bundle and metadata_filename
+* is not NULL, dump the metadata into this file (add _<n> for
+* more than one bundle)  If NULL pretty print to stdout.
+*******************************************************************************/
+int
+recv_bpq(dtn_handle_t handle,
+    dtn_timeval_t timeout,
+    char * filename,
+    char * metadata_fn,
+    char * query_id,
+    int count,
+    int verbose)
+{
+    int ret = 0, err = 0, num_blocks, i, j;
+    int has_bpq_block = 0;
+    dtn_bundle_spec_t               bundle_spec;
+    dtn_extension_block_t*          bpq_blocks;
+    dtn_extension_block_t*          metadata_blocks;
+    dtn_bpq_extension_block_data_t  bpq_block_data;
+    dtn_bundle_payload_t            payload;
+    int								decoding_len;
+    u_int64_t						ontology;
+    u_int32_t						metadata_lgth;
+    char *							metadata_str;
+    js_parser						metadata_parser;
+    char							pfn[PATH_MAX], mfn[PATH_MAX];
+    FILE *							mstream;
+
+
+    for(j = 0; (count == 0) || (j < count); ++j) {
+        memset(&bundle_spec, 0, sizeof(bundle_spec));
+        memset(&bpq_block_data, 0, sizeof(dtn_bpq_extension_block_data_t));
+        memset(&payload, 0, sizeof(payload));
+        err = 0;
+
+        // recv the bpq bundle
+        if (verbose) fprintf(stdout, "blocking waiting for dtn_recv\n");
+        ret = dtn_recv(handle, &bundle_spec, DTN_PAYLOAD_FILE, &payload, timeout);
+        if (ret != DTN_SUCCESS) {
+            fprintf(stderr, "error receiving bundle: %d (%s)\n",
+                             ret, dtn_strerror(dtn_errno(handle)));
+            err = 1;
+            continue;
+        } else if (verbose) {
+            fprintf(stdout, "bundle num %d received successfully: id %s,%llu.%llu\n",
+                             j+1,
+                             bundle_spec.source.uri,
+                             bundle_spec.creation_ts.secs,
+                             bundle_spec.creation_ts.seqno);
+
+            fprintf(stdout, "Source: %s\n", bundle_spec.source.uri);
+            fprintf(stdout, "Destination: %s\n", bundle_spec.dest.uri);
+            fprintf(stdout, "Reply-To: %s\n", bundle_spec.replyto.uri);
+        }
+
+        // extract the bpq
+        num_blocks = bundle_spec.blocks.blocks_len;
+        bpq_blocks = bundle_spec.blocks.blocks_val;
+
+        for (i = 0; i < num_blocks; ++i) {
+            if (bpq_blocks[i].type == QUERY_EXTENSION_BLOCK) {
+                has_bpq_block = 1;
+
+                if (verbose) fprintf(stdout, "bundle contains a "
+                                             "BPQ extension block\n");
+
+                if ( bpq_blocks[i].data.data_len <= 0 ||
+                     bpq_blocks[i].data.data_val == NULL) {
+                    fprintf(stderr, "error decoding query bundle: %d\n", ret);
+                    err = 1;
+                    break;
+                }
+
+                ret = char_array_to_bpq((u_char*)bpq_blocks[i].data.data_val,
+                                        bpq_blocks[i].data.data_len,
+                                        &bpq_block_data,
+                                        verbose);
+                if (ret != DTN_SUCCESS) {
+                    fprintf(stderr, "error decoding query bundle: %d\n", ret);
+                    err = 1;
+                    break;
+                }
+
+                if (strlen(query_id) > 0){
+                	if ((bpq_block_data.query_id.query_id_len != (strlen(query_id) + 1)) ||
+                		((strcmp(bpq_block_data.query_id.query_id_val, query_id) != 0))) {
+                		fprintf(stderr, "incoming query_id (%s) does not match expected value",
+                				bpq_block_data.query_id.query_id_val);
+                		err = 1;
+                		break;
+                	}
+                } else {
+                	if (verbose) {
+                		printf("Incoming query id is %s", bpq_block_data.query_id.query_id_val);
+                	}
+                }
+
+                if (verbose) fprintf(stdout, "BPQ query(%s)\n", bpq_block_data.query.query_val);
+                if (strlen(filename) == 0) {
+                	if (count > 1) {
+                		snprintf(pfn, PATH_MAX, "%s_%d",
+                				 bpq_block_data.query.query_val, (j + 1));
+                	}else {
+                		strncpy(pfn, bpq_block_data.query.query_val, PATH_MAX);
+                	}
+                } else {
+                	if (count > 1) {
+                   		snprintf(pfn, PATH_MAX, "%s_%d", filename, (j + 1));
+                	} else {
+                		strncpy(pfn, filename, PATH_MAX);
+                	}
+                }
+                if (verbose) fprintf(stdout, "Writing payload to %s\n", pfn);
+                break;
+            }
+            // Check for metadata block
+            num_blocks = bundle_spec.metadata.metadata_len;
+            metadata_blocks = bundle_spec.metadata.metadata_val;
+
+            ontology = 0xffffffff;
+
+            for (i = 0; i < num_blocks; ++i) {
+            	// Decode Ontology
+            	if ( (decoding_len = sdnv_decode (metadata_blocks[i].data.data_val,
+            			 	 	 	 	 	 	  // Nul terminated
+            									  metadata_blocks[i].data.data_len - 1,
+            	    							  &ontology)) == -1 ) {
+            	        fprintf (stderr, "Error decoding metadata ontology\n");
+            	        return -1;
+            	}
+            	// Assume only one JSON metadata block
+            	metadata_str = &metadata_blocks[i].data.data_val[decoding_len];
+				// Length includes Nul terminator
+            	metadata_lgth = metadata_blocks[i].data.data_len - decoding_len;
+            	if (ontology == JSON_METADATA_BLOCK) {
+            		break;
+            	}
+            }
+            if (ontology != JSON_METADATA_BLOCK) {
+				if (verbose) fprintf(stdout, "No JSON metadata in bundle %d", (j + 1));
+			} else{
+				// Extract metadata and check is valid JSON
+				if (json_parser(&metadata_parser, metadata_str) == JS_SUCCESS) {
+					if (strlen(metadata_fn) > 0) {
+						if (count > 1) {
+							snprintf(mfn, PATH_MAX, "%s_%d", metadata_fn, (j + 1));
+						} else {
+							strcpy(mfn, metadata_fn);
+						}
+					} else {
+						snprintf(mfn, PATH_MAX, "%s.mdt", pfn);
+					}
+				} else {
+					fprintf(stderr, "Unable to parse metadata in bundle %d\n", (j + 1));
+					return -1;
+				}
+				if (verbose) fprintf(stdout, "Metadata written to %s\n", mfn);
+			}
+		}
+
+
+        if(!has_bpq_block) {
+            fprintf(stderr, "no bpq block found in bundle %d:\n", (j + 1));
+            for (i = 0; i < num_blocks; ++i)
+                fprintf(stderr, "\tblock[%d] : type = %d\n", i, bpq_blocks[i].type);
+
+            continue;
+        }
+
+        if(err)
+            continue;
+
+        // handle the payload file
+        ret = handle_file_transfer(bundle_spec, payload, pfn, verbose);
+        if (ret != DTN_SUCCESS) {
+            fprintf(stderr, "error handling file transfer: %d\n", ret);
+        } else if (verbose) {
+            fprintf(stdout, "sucessfully handled file transfer\n");
+        }
+
+        // Write out metadata if any
+        if (ontology == JSON_METADATA_BLOCK) {
+        	if ((mstream = fopen(mfn, "w")) == NULL) {
+        		fprintf(stderr, "Unable to opoen metadata file (%s) for writing.\n", mfn);
+        		return -1;
+        	}
+        	if (fwrite(metadata_str, metadata_lgth, sizeof(*metadata_str), mstream) != metadata_lgth) {
+        		fprintf(stderr, "Write of metadata in file (%s) failed (%s)", mfn, strerror(errno));
+        		fclose(mstream);
+        		return -1;
+        	}
+        	fclose(mstream);
+        	if (verbose) fprintf(stdout, "Metadata successfully written to file (%s)", mfn);
+
+        }
+
+        dtn_free_payload(&payload);
+    }
+    return ret;
+}
+
+/*******************************************************************************
+* report_type_to_str:  convert status report type flag to string
+*
+*******************************************************************************/
+char *
+report_type_to_str(dtn_status_report_flags_t status_type)
+{
+	switch (status_type) {
+		case STATUS_RECEIVED:
+			return "bundle received";
+			break;
+		case STATUS_CUSTODY_ACCEPTED:
+			return "custody accepted";
+			break;
+		case STATUS_FORWARDED:
+			return "bundle forwarded";
+			break;
+		case STATUS_DELIVERED:
+			return "bundle delivered";
+			break;
+		case STATUS_DELETED:
+			return "bundle deleted";
+			break;
+		case STATUS_ACKED_BY_APP:
+			return "acknowledged by app";
+			break;
+		default:
+			return "unrecgnized status report";
+			break;
+	}
+}
diff -r 52e2b403edd4 -r 00bddbb095de applib/bpq_api.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/applib/bpq_api.h	Fri Jan 04 17:01:21 2013 +0000
@@ -0,0 +1,130 @@
+/*
+ *    Copyright 2012 Trinity College Dublin
+ * 
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ * 
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+#ifndef BPQ_API_H
+#define BPQ_API_H
+
+#include "dtn_types.h"
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/*************************************************************
+ *
+ *                BPQ Block Types and Macros
+ *    NOTE: The structure and values in this file need to be
+ *    synchronized with those in servlib/bundling/BPQBlock.h
+ *
+ *************************************************************/
+
+/**
+ * BPQ Extension block kind.
+ *
+ *     BPQ_BLOCK_KIND_QUERY                       - query bundles
+ *     BPQ_BLOCK_KIND_RESPONSE                    - response bundles
+ *     BPQ_BLOCK_KIND_RESPONSE_DO_NOT_CACHE_FRAG  - response bundles that should not be cached unless complete
+ *     BPQ_BLOCK_KIND_PUBLISH                     - publish bundles - treated like response except local storage
+ */
+
+enum dtn_bpq_extension_block_kind_t {
+    BPQ_BLOCK_KIND_QUERY = 0x00,
+    BPQ_BLOCK_KIND_RESPONSE = 0x01,
+    BPQ_BLOCK_KIND_RESPONSE_DO_NOT_CACHE_FRAG = 0x02,
+    BPQ_BLOCK_KIND_PUBLISH = 0x03,
+};
+typedef enum dtn_bpq_extension_block_kind_t dtn_bpq_extension_block_kind_t;
+
+/**
+ * BPQ Extension block matching rule. (More may be added later)
+ *
+ *     BPQ_MATCHING_RULE_EXACT
+ */
+
+enum dtn_bpq_extension_block_matching_rule_t {
+    BPQ_MATCHING_RULE_EXACT = 0x00,
+};
+typedef enum dtn_bpq_extension_block_matching_rule_t dtn_bpq_extension_block_matching_rule_;
+
+struct dtn_bpq_extension_block_data_t {
+    u_int kind;
+    u_int matching_rule;
+    struct {
+    	dtn_timestamp_t creation_ts;
+    	u_int source_len;
+    	dtn_endpoint_id_t source;
+    } original_id;
+    struct {
+        u_int query_id_len;
+        char* query_id_val;
+    } query_id;
+    struct {
+        u_int query_len;
+        char* query_val;
+    } query;
+    struct {
+        u_int num_frag_returned;
+        u_int *frag_offsets;
+        u_int *frag_lenghts;
+    } fragments;
+};
+typedef struct dtn_bpq_extension_block_data_t dtn_bpq_extension_block_data_t;
+
+/**
+ * Metadata block 'ontology type' declarations for use with BPQ blocks
+ */
+#define JSON_METADATA_BLOCK 192
+
+extern dtn_endpoint_id_t *parse_eid(dtn_handle_t handle,
+                                    dtn_endpoint_id_t * eid,
+                                    const char * str,
+                                    int verbose);
+extern int bpq_to_char_array(const dtn_bpq_extension_block_data_t * bpq,
+                             char* buf,
+                             size_t buf_len,
+                             int verbose);
+extern int char_array_to_bpq(const u_char* buf,
+                             size_t buf_len,
+                             dtn_bpq_extension_block_data_t * bpq,
+                             int verbose);
+extern char *report_type_to_str(dtn_status_report_flags_t status_type);
+extern int send_bpq(dtn_handle_t handle,
+					const dtn_bpq_extension_block_kind_t kind,
+		            const dtn_endpoint_id_t * src_eid,
+		            const dtn_endpoint_id_t * dest_eid,
+		            const dtn_endpoint_id_t * reply_eid,
+		            char * cache_name,
+		            char * query_id,
+		            char * metadata,
+		            char * payload_file,
+		            int matching_rule,
+		            int bundle_expiry,
+		            dtn_bundle_priority_t  priority,
+		            int delivery_options,
+		            int verbose);
+extern int recv_bpq(dtn_handle_t handle,
+					dtn_timeval_t timeout,
+					char * filename,
+					char * metadata_fn,
+					char * query_id,
+					int count,
+					int verbose);
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif /* BPQ_API_H */
diff -r 52e2b403edd4 -r 00bddbb095de applib/dtn_api.h
--- a/applib/dtn_api.h	Mon Nov 19 11:58:18 2012 +0000
+++ b/applib/dtn_api.h	Fri Jan 04 17:01:21 2013 +0000
@@ -287,6 +287,46 @@
  */
 const char* dtn_status_report_reason_to_str(dtn_status_report_reason_t err);
 
+/*************************************************************
+ *
+ *     Enumerations and Constants needed implicitly in API
+ *          (For items embedded in opaque data blocks
+ *                    passing across API)
+ *
+ *************************************************************/
+
+/**
+ * Valid type codes for bundle blocks.
+ * (See http://www.dtnrg.org/wiki/AssignedNamesAndNumbers)
+ * THis is copied from servlib/bundling/BundleProtcocol.h
+ */
+typedef enum {
+    PRIMARY_BLOCK               = 0x000, ///< INTERNAL ONLY -- NOT IN SPEC
+    PAYLOAD_BLOCK               = 0x001, ///< Defined in RFC5050
+    BUNDLE_AUTHENTICATION_BLOCK = 0x002, ///< Defined in RFC6257
+    PAYLOAD_SECURITY_BLOCK      = 0x003, ///< Defined in RFC6257
+    CONFIDENTIALITY_BLOCK       = 0x004, ///< Defined in RFC6257
+    PREVIOUS_HOP_BLOCK          = 0x005, ///< Defined in RFC6259
+    METADATA_BLOCK              = 0x008, ///< Defined in RFC6258
+    EXTENSION_SECURITY_BLOCK    = 0x009, ///< Defined in RFC6257
+    SESSION_BLOCK               = 0x00c, ///< NOT IN SPEC YET
+    AGE_BLOCK                   = 0x00a, ///< draft-irtf-dtnrg-bundle-age-block-01
+    QUERY_EXTENSION_BLOCK       = 0x00b, ///< draft-irtf-dtnrg-bpq-00
+    SEQUENCE_ID_BLOCK           = 0x010, ///< NOT IN SPEC YET
+    OBSOLETES_ID_BLOCK          = 0x011, ///< NOT IN SPEC YET
+    API_EXTENSION_BLOCK         = 0x100, ///< INTERNAL ONLY -- NOT IN SPEC
+    UNKNOWN_BLOCK               = 0x101, ///< INTERNAL ONLY -- NOT IN SPEC
+} bundle_block_type_t;
+
+/**
+ * Ontology numbers used in Metadata Blocks - see RFC 6258
+ */
+typedef enum {
+	ONTOLOGY_URI				= 0x01,  ///< Metadata block carries URI
+	ONTOLOGY_EXPT_MIN			= 0xc0,  ///< Low end of experimental range
+	ONTOLOGY_EXPT_MAX			= 0xff,  ///< High end of experimental range
+} metadata_ontology_type_t;
+
 #ifdef  __cplusplus
 }
 #endif
diff -r 52e2b403edd4 -r 00bddbb095de applib/dtn_types.h
--- a/applib/dtn_types.h	Mon Nov 19 11:58:18 2012 +0000
+++ b/applib/dtn_types.h	Fri Jan 04 17:01:21 2013 +0000
@@ -262,40 +262,6 @@
 typedef enum dtn_extension_block_flags_t dtn_extension_block_flags_t;
 
 /**
- *	   BPQ extension block type
- */
-
-#define DTN_BPQ_BLOCK_TYPE 0x0B
-
-/**
- * BPQ Extension block kind.
- *
- *     BPQ_BLOCK_KIND_QUERY							- query bundles
- *     BPQ_BLOCK_KIND_RESPONSE						- response bundles
- *     BPQ_BLOCK_KIND_RESPONSE_DO_NOT_CACHE_FRAG	- response bundles that should not be cached unless complete
- *     BPQ_BLOCK_KIND_PUBLISH						- publish bundles - treated like response except local storage
- */
-
-enum dtn_bpq_extension_block_kind_t {
-    BPQ_BLOCK_KIND_QUERY = 0x00,
-    BPQ_BLOCK_KIND_RESPONSE = 0x01,
-    BPQ_BLOCK_KIND_RESPONSE_DO_NOT_CACHE_FRAG = 0x02,
-    BPQ_BLOCK_KIND_PUBLISH = 0x03,
-};
-typedef enum dtn_bpq_extension_block_kind_t dtn_bpq_extension_block_kind_t;
-
-/**
- * BPQ Extension block matching rule. (More may be added later)
- *
- *     BPQ_MATCHING_RULE_EXACT
- */
-
-enum dtn_bpq_extension_block_matching_rule_t {
-    BPQ_MATCHING_RULE_EXACT = 0x00,
-};
-typedef enum dtn_bpq_extension_block_matching_rule_t dtn_bpq_extension_block_matching_rule_t;
-
-/**
  * Extension block.
  */
 
@@ -309,26 +275,6 @@
 };
 typedef struct dtn_extension_block_t dtn_extension_block_t;
 
-struct dtn_bpq_extension_block_data_t {
-    u_int kind;
-    u_int matching_rule;
-    struct {
-    	dtn_timestamp_t creation_ts;
-    	u_int source_len;
-    	dtn_endpoint_id_t source;
-    } original_id;
-    struct {
-        u_int query_len;
-        char* query_val;
-    } query;
-    struct {
-        u_int num_frag_returned;
-        u_int *frag_offsets;
-        u_int *frag_lenghts;
-    } fragments;
-};
-typedef struct dtn_bpq_extension_block_data_t dtn_bpq_extension_block_data_t;
-
 /**
  * A Sequence ID is a vector of (EID, counter) values in the following
  * text format:
@@ -492,9 +438,6 @@
 extern  bool_t xdr_dtn_bundle_delivery_opts_t (XDR *, dtn_bundle_delivery_opts_t*);
 extern  bool_t xdr_dtn_extension_block_flags_t (XDR *, dtn_extension_block_flags_t*);
 extern  bool_t xdr_dtn_extension_block_t (XDR *, dtn_extension_block_t*);
-extern  bool_t xdr_dtn_bpq_extension_block_kind_t (XDR *, dtn_bpq_extension_block_kind_t*);
-extern  bool_t xdr_dtn_bpq_extension_block_matching_rule_t (XDR *, dtn_bpq_extension_block_matching_rule_t*);
-extern  bool_t xdr_dtn_bpq_extension_block_data_t (XDR *, dtn_bpq_extension_block_data_t*);
 extern  bool_t xdr_dtn_sequence_id_t (XDR *, dtn_sequence_id_t*);
 extern  bool_t xdr_dtn_bundle_spec_t (XDR *, dtn_bundle_spec_t*);
 extern  bool_t xdr_dtn_bundle_id_t (XDR *, dtn_bundle_id_t*);
@@ -518,9 +461,6 @@
 extern bool_t xdr_dtn_bundle_delivery_opts_t ();
 extern bool_t xdr_dtn_extension_block_flags_t ();
 extern bool_t xdr_dtn_extension_block_t ();
-extern bool_t xdr_dtn_bpq_extension_block_kind_t ();
-extern bool_t xdr_dtn_bpq_extension_block_matching_rule_t ();
-extern bool_t xdr_dtn_bpq_extension_block_data_t ();
 extern bool_t xdr_dtn_sequence_id_t ();
 extern bool_t xdr_dtn_bundle_spec_t ();
 extern bool_t xdr_dtn_bundle_id_t ();
diff -r 52e2b403edd4 -r 00bddbb095de applib/json.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/applib/json.c	Fri Jan 04 17:01:21 2013 +0000
@@ -0,0 +1,951 @@
+/*
+ *    Copyright 2010 - 2012 Trinity College Dublin
+ *    Copyright 2012 Folly Consulting Ltd
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include <dtn-config.h>
+#endif
+
+#include <stdio.h>
+#include <unistd.h>
+#include <errno.h>
+#include <strings.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include "json.h"
+
+static jserr_t js_parse_object(js_parser *parser, jstok_t **new_tok);
+static jserr_t js_parse_array(js_parser *parser, jstok_t **new_tok);
+/**
+ * Allocates a fresh unused token from the token pool.
+ */
+static jstok_t *
+js_alloc_token(js_parser *parser)
+{
+	jstok_t *tok;
+	int i;
+	if (parser->toknext >= parser->last_token) {
+		parser->last_token += TOK_QUANTUM;
+		parser->tokens = (jstok_t *)realloc(parser->tokens,
+				                            (parser->last_token + 1) * sizeof(jstok_t));
+		if (parser->tokens == NULL) {
+			return NULL;
+		}
+		for (i = parser->toknext; i <= parser->last_token; i++) {
+			parser->tokens[i].type = JS_UNUSED;
+		}
+	}
+	tok = &(parser->tokens[parser->toknext++]);
+	tok->start = tok->end = NULL;
+	tok->size = 0;
+	tok->parent = NULL;
+	tok->child = NULL;
+	tok->sibling = NULL;
+	return tok;
+}
+
+/**
+ * Fills token type and boundaries.
+ */
+static void
+js_fill_token(jstok_t *token, jstok_t *parent, jstype_t type, char *start, char *after) {
+	token->type = type;
+	token->start = start;
+	token->end = after - 1;
+	token->size = 1;
+	token->parent = parent;
+}
+
+/**
+ * Discard any white space between tokens
+ */
+static void
+js_discard_whitespace(js_parser *parser)
+{
+	char c = *(parser->pos);
+
+	while(1) {
+		switch (c) {
+		case '\t' : case '\r' : case '\n' : case ' ':
+			c = *(++parser->pos);
+			break;
+		case '\0':
+			return;
+		default:
+			return;
+		}
+	}
+	/* NOTREACHED */
+	return;
+}
+
+/**
+ * Check for whitespace characters
+ */
+static int
+js_isspace(char c)
+{
+	return ((c == '\t') || (c == '\r') || (c == '\n') || (c == ' '));
+}
+
+/**
+ * Stack another level in the parser.
+ */
+static jserr_t
+js_push_token_stack(js_parser *parser, jstok_t *token)
+{
+	parser->stack_level++;
+	if (parser->stack_level >= parser->max_stack_depth) {
+		parser->max_stack_depth += STK_QUANTUM;
+		parser->tokstack = (jstok_t **)realloc(parser->tokstack,
+				                               (parser->max_stack_depth + 1) * sizeof(jstok_t*));
+		if (parser->tokstack == NULL) {
+			return JS_ERROR_NOMEM;
+		}
+	}
+	parser->tokstack[parser->stack_level] = token;
+	parser->parent_tok = token;
+	return JS_SUCCESS;
+}
+
+/**
+ * Pop the level stack in the parser
+ */
+static jstok_t *
+js_pop_token_stack(js_parser *parser)
+{
+	(parser->stack_level)--;
+	if (parser->stack_level < 0) {
+		return NULL;
+	}
+	parser->parent_tok = parser->tokstack[parser->stack_level];
+	return parser->parent_tok;
+}
+
+/**
+ * Fills next available token with JSON null primitive if input string is correct.
+ */
+static jserr_t
+js_parse_null(js_parser *parser, jstok_t **new_tok)
+{
+	// Expect parser input to be situated at first character of 'null'
+	int exp_len = strlen(JS_NULL_STR);
+	char *start = parser->pos;
+
+	if (strncmp(start, JS_NULL_STR, exp_len) != 0){
+		*new_tok = NULL;
+		return JS_ERROR_INVAL;
+	}
+	parser->pos +=exp_len;
+	*new_tok = js_alloc_token(parser);
+	if (*new_tok == NULL) {
+		return JS_ERROR_NOMEM;
+	}
+	js_fill_token(*new_tok, parser->parent_tok, JS_NULL, start, parser->pos);
+	return JS_SUCCESS;
+
+}
+
+/**
+ * Fills next available token with JSON true primitive if input string is correct.
+ */
+static jserr_t
+js_parse_true(js_parser *parser, jstok_t **new_tok)
+{
+	// Expect parser input to be situated at first character of 'true'
+	int exp_len = strlen(JS_TRUE_STR);
+	char *start = parser->pos;
+
+	if (strncmp(start, JS_TRUE_STR, exp_len) != 0){
+		*new_tok = NULL;
+		return JS_ERROR_INVAL;
+	}
+	parser->pos +=exp_len;
+	*new_tok = js_alloc_token(parser);
+	if (*new_tok == NULL) {
+		return JS_ERROR_NOMEM;
+	}
+	js_fill_token(*new_tok, parser->parent_tok, JS_TRUE, start, parser->pos);
+	return JS_SUCCESS;
+
+}
+
+/**
+ * Fills next available token with JSON false primitive if input string is correct.
+ */
+static jserr_t
+js_parse_false(js_parser *parser, jstok_t **new_tok)
+{
+	// Expect parser input to be situated at first character of 'false'
+	int exp_len = strlen(JS_FALSE_STR);
+	char *start = parser->pos;
+
+	if (strncmp(start, JS_FALSE_STR, exp_len) != 0){
+		*new_tok = NULL;
+		return JS_ERROR_INVAL;
+	}
+	parser->pos +=exp_len;
+	*new_tok = js_alloc_token(parser);
+	if (*new_tok == NULL) {
+		return JS_ERROR_NOMEM;
+	}
+	js_fill_token(*new_tok, parser->parent_tok, JS_FALSE, start, parser->pos);
+	return JS_SUCCESS;
+
+}
+
+/**
+ * Fills next available token with JSON number primitive if input string is correct.
+ * A JSON number is (-)?(0|0.[0-9]*)|[1-9][0-9]*(.[0-9]*)?)([eE]([+-])?[0-9]+)?
+ */
+#define ERR_IF_ENDED if(*p == '\0'){parser->pos = p; return JS_ERROR_PART;}
+#define OK_STR_END if((c = *++p) == '\0') goto finish
+static jserr_t
+js_parse_number(js_parser *parser, jstok_t **new_tok)
+{
+	// Expect parser input to be situated at first character of 'number'
+	char *start = parser->pos;
+	char *p = start;
+	char c;
+	*new_tok = NULL;
+
+	if (*p == '-') p++;
+	ERR_IF_ENDED
+	if ((c =*p) == '0') {
+		OK_STR_END;
+		if (((c = *p)== 'e') || (c == 'E')){
+			p++;
+			goto exponent;
+		}
+		if (js_isspace(c) || (c == ',') || (c == '}') || (c == ']')) {
+			goto finish;
+		}
+		if (*p != '.') {
+			parser->pos = p;
+			return JS_ERROR_INVAL;
+		}
+	} else if ((c >= '1') && (c <= '9')) {
+		while (1) {
+			OK_STR_END;
+			if ((c >= '0') && (c <= '9')) continue;
+			if ((c == 'e') || (c == 'E')) {
+				p++;
+				goto exponent;
+			}
+			if (js_isspace(c) || (c == ',') || (c == '}') || (c == ']')) {
+				goto finish;
+			}
+			if (c != '.') {
+				parser->pos = p;
+				return JS_ERROR_INVAL;
+			}
+		}
+	}
+
+	// Fractional part
+	while (1) {
+		OK_STR_END;
+		if ((c >= '0') && (c <= '9')) continue;
+		if (js_isspace(c) || (c == ',') || (c == '}') || (c == ']')) {
+			goto finish;
+		}
+		if (!((c == 'e') || (c == 'E'))) {
+			parser->pos = p;
+			return JS_ERROR_INVAL;
+		}
+		p++;
+		break;
+	}
+
+	exponent:
+		ERR_IF_ENDED;
+		if (((c = *p) == '+') || (c == '-')) {
+			p++;
+			ERR_IF_ENDED;
+		}
+		if (!(((c = *p) >= '0') && (c <= '9'))) {
+			parser->pos = p;
+			return JS_ERROR_INVAL;
+		}
+		while (1) {
+			OK_STR_END;
+			if ((c >= '0') && (c <= '9')) continue;
+			if (!(js_isspace(c) || (c == ',') || (c == '}') || (c == ']'))) {
+				parser->pos = p;
+				return JS_ERROR_INVAL;
+			}
+			break;
+		}
+	finish:
+		parser->pos = p;
+		*new_tok = js_alloc_token(parser);
+		if (*new_tok == NULL) {
+			return JS_ERROR_NOMEM;
+		}
+		js_fill_token(*new_tok, parser->parent_tok, JS_NUMBER, start, parser->pos);
+		return JS_SUCCESS;
+}
+
+/**
+ * Fills next token with JSON string.
+ */
+static jserr_t
+js_parse_string(js_parser *parser, jstok_t **new_tok)
+{
+	// Expect parser input to be situated at first character of 'string' (i.e., ")
+	char *start = parser->pos;
+	char c;
+	char *p = start;
+	int i;
+
+	*new_tok = NULL;
+
+	/* Skip starting quote */
+	if (*p != '"') {
+		return JS_ERROR_INVAL;
+	}
+	for (p++; (c = *p) != '\0'; p++) {
+
+		/* Quote: end of string */
+		if (c == '\"') {
+			parser->pos = p + 1;
+			*new_tok = js_alloc_token(parser);
+			if (*new_tok == NULL) {
+				return JS_ERROR_NOMEM;
+			}
+
+			js_fill_token(*new_tok, parser->parent_tok, JS_STRING, start + 1, p);
+			return JS_SUCCESS;
+		}
+
+		/* Backslash: Quoted symbol expected */
+		if (c == '\\') {
+
+			switch (c = *(++p)) {
+				/* Allowed escaped symbols */
+				case '\"': case '/' : case '\\' : case 'b' :
+				case 'f' : case 'r' : case 'n'  : case 't' :
+					break;
+				/* Allows escaped symbol \uXXXX */
+				case 'u':
+					++p;
+					for (i = 0; i < 4; c = *(p++), i++ ) {
+						if (!(((c >= '0') && (c <= '9')) ||
+							 ((c >= 'a') && (c <= 'f')) ||
+							 ((c >= 'A') && (c <= 'F')))) {
+							parser->pos = p;
+							return JS_ERROR_INVAL;
+						}
+					}
+					break;
+				/* Unexpected symbol */
+				default:
+					parser->pos = p;
+					return JS_ERROR_INVAL;
+			}
+		}
+	}
+
+	// Unterminated string
+	parser->pos = p;
+	return JS_ERROR_PART;
+}
+
+/**
+ * Fills next token with whatever PRIMITIVE is next (string, number, boolean or null).
+ */
+static jserr_t
+js_parse_primitive(js_parser *parser, jstok_t **new_tok)
+{
+	char c;
+	jserr_t r;
+
+	// Expect parser input to be situated at first character of next primitive,
+	// give or take some white space.
+	js_discard_whitespace(parser);
+
+	c = *(parser->pos);
+
+	switch (c) {
+	case '\"':
+		r = js_parse_string(parser, new_tok);
+		break;
+	case 't':
+		r = js_parse_true(parser, new_tok);
+		break;
+	case 'f':
+		r = js_parse_false(parser, new_tok);
+		break;
+	case 'n':
+		r = js_parse_null(parser, new_tok);
+		break;
+	case '}':
+	case ']':
+		// Empty array or object
+		*new_tok = NULL;
+		r = JS_SUCCESS;
+		break;
+	case '\0':
+		r = JS_ERROR_PART;
+		break;
+	default:
+		if ((c == '-') || ((c >= '0') && (c <= '9'))) {
+			r = js_parse_number(parser, new_tok);
+			break;
+		}
+		r = JS_ERROR_INVAL;
+		break;
+	}
+	return r;
+}
+
+/*
+ * Parse the value part of a name-value pair or and array entry
+ * this can a primitive, a nested object or an array
+ */
+static jserr_t
+js_parse_value(js_parser *parser, jstok_t **new_tok)
+{
+	char c;
+
+	/*
+	 * Next non-whitespace character decides what we have here
+	 */
+	js_discard_whitespace(parser);
+	c = *(parser->pos);
+	switch (c) {
+	case '\0':
+		return JS_ERROR_PART;
+	case '{':
+		return js_parse_object(parser, new_tok);
+	case '[':
+		return js_parse_array(parser, new_tok);
+	default:
+		return js_parse_primitive(parser, new_tok);
+	}
+	/* NOT REACHED */
+}
+
+/**
+ * Fills next 3 tokens with a name-value pair. The new_tok is the VALUE_PAIR tokem
+ */
+static jserr_t
+js_parse_value_pair(js_parser *parser, jstok_t **new_tok)
+{
+	char c;
+	jserr_t r;
+
+	jstok_t *name_tok, *value_tok;
+
+	/**
+	 * Expect parser input to be situated at first character of next value name,
+	 * give or take some whitespace.
+	 * This should be a string followed by a ':' maybe surrounded by whitespace
+	 * and a primitive.
+	 */
+	js_discard_whitespace(parser);
+
+	/*
+	 * Allocate a token for the VALUE PAIR and push the stack
+	 */
+	*new_tok = js_alloc_token(parser);
+	if (*new_tok == NULL) {
+		return JS_ERROR_NOMEM;
+	}
+
+	js_fill_token(*new_tok, parser->parent_tok, JS_VALPAIR, parser->pos, NULL);
+	r = js_push_token_stack(parser, *new_tok);
+	if ( r != JS_SUCCESS ){
+		return r;
+	}
+
+	r = js_parse_string(parser, &name_tok);
+	if (r != JS_SUCCESS) {
+		return r;
+	}
+	(*new_tok)->child = name_tok;
+	js_discard_whitespace(parser);
+	c = *(parser->pos);
+	if (c == '\0') {
+		return JS_ERROR_PART;
+	}
+	if (c != ':') {
+		return JS_ERROR_INVAL;
+	}
+	parser->pos++;
+
+	js_discard_whitespace(parser);
+	r = js_parse_value(parser, &value_tok);
+	if (r != JS_SUCCESS) {
+		return r;
+	}
+	name_tok->sibling = value_tok;
+
+	(*new_tok)->end = parser->pos - 1;
+	(*new_tok)->size = (name_tok->size) + (value_tok->size);
+
+	if (js_pop_token_stack(parser) == NULL) {
+		return JS_ERROR_INVAL;
+	}
+	return JS_SUCCESS;
+}
+
+/**
+ * Parse a JSON array (and anything subsidiary)
+ */
+static jserr_t
+js_parse_array(js_parser *parser, jstok_t **new_tok)
+{
+	char c;
+	jserr_t r;
+	jstok_t *token, *value_tok, *prev_value_tok;
+
+	js_discard_whitespace(parser);
+	*new_tok = NULL;
+	/*
+	 * An array consists of an list of JSON values separated by commas.
+	 * Check that we have right starter character
+	 * Allocate token for object
+	 */
+	if (*(parser->pos) != '[') {
+		return JS_ERROR_INVAL;
+	}
+	token = js_alloc_token(parser);
+	if (token == NULL) {
+		return JS_ERROR_NOMEM;
+	}
+
+	js_fill_token(token, parser->parent_tok, JS_ARRAY, parser->pos, NULL);
+	r = js_push_token_stack(parser, token);
+	if (r != JS_SUCCESS) {
+		return r;
+	}
+
+	parser->pos++;
+	js_discard_whitespace(parser);
+	c = *(parser->pos);
+	if ( c == '\0') {
+		return JS_ERROR_PART;
+	}
+	// Special case of empty array
+	if ( c != ']') {
+		r = js_parse_value(parser, &value_tok);
+		if (r != JS_SUCCESS) {
+			return r;
+		}
+		token->child = value_tok;
+		prev_value_tok = value_tok;
+		token->size += value_tok->size;
+		while (1) {
+			js_discard_whitespace(parser);
+			c = *(parser->pos);
+			if (c == '\0') {
+				return JS_ERROR_PART;
+			}
+			if (c == ']') {
+				break;
+			}
+			if (c != ',') {
+				return JS_ERROR_INVAL;
+			}
+			parser->pos++;
+			r = js_parse_value(parser, &value_tok);
+			if (r != JS_SUCCESS) {
+				return r;
+			}
+			prev_value_tok->sibling = value_tok;
+			prev_value_tok = value_tok;
+			token->size += value_tok->size;
+		}
+	}
+	token->end = parser->pos;
+	parser->pos++;
+	(void)js_pop_token_stack(parser);
+	*new_tok = token;
+	return JS_SUCCESS;
+}
+
+/**
+ * Parse a JSON object (and anything subsidiary)
+ */
+static jserr_t
+js_parse_object(js_parser *parser, jstok_t **new_tok)
+{
+	char c;
+	jserr_t r;
+	jstok_t *token, *valpair_tok, *prev_valpair_tok;
+
+	js_discard_whitespace(parser);
+	*new_tok = NULL;
+	/*
+	 * An object consists of an unordered list of name-value pairs separated by commas.
+	 * Check that we have right starter character
+	 * Allocate token for object
+	 */
+	if (*(parser->pos) != '{') {
+		return JS_ERROR_INVAL;
+	}
+	token = js_alloc_token(parser);
+	if (token == NULL) {
+		return JS_ERROR_NOMEM;
+	}
+
+	js_fill_token(token, parser->parent_tok, JS_OBJECT, parser->pos, NULL);
+	r = js_push_token_stack(parser, token);
+
+	parser->pos++;
+	js_discard_whitespace(parser);
+	c = *(parser->pos);
+	if ( c == '\0') {
+		return JS_ERROR_PART;
+	}
+	// Special case of empty object
+	if (c != '}') {
+		if (c != '\"') {
+			return JS_ERROR_INVAL;
+		}
+		r = js_parse_value_pair(parser, &valpair_tok);
+		if (r != JS_SUCCESS) {
+			return r;
+		}
+		token->child = valpair_tok;
+		prev_valpair_tok = valpair_tok;
+		token->size += valpair_tok->size;
+		while (1) {
+			js_discard_whitespace(parser);
+			c = *(parser->pos);
+			if (c == '\0') {
+				return JS_ERROR_PART;
+			}
+			if (c == '}') {
+				break;
+			}
+			if (c != ',') {
+				return JS_ERROR_INVAL;
+			}
+			parser->pos++;
+			r = js_parse_value_pair(parser, &valpair_tok);
+			if (r != JS_SUCCESS) {
+				return r;
+			}
+			prev_valpair_tok->sibling = valpair_tok;
+			prev_valpair_tok = valpair_tok;
+			token->size += valpair_tok->size;
+		}
+	}
+	token->end = parser->pos;
+	parser->pos++;
+	(void)js_pop_token_stack(parser);
+	*new_tok = token;
+	return JS_SUCCESS;
+}
+
+/**
+ * Main JSON string parser.
+ */
+jserr_t
+json_parser(js_parser *parser, const char *json_string)
+{
+	jserr_t r;
+	char c;
+	jstok_t *token;
+	int l = strlen(json_string);
+
+	/*
+	 * Initialise parser
+	 */
+	parser->json_string = (char *)malloc((l + 1) * sizeof(char));
+	parser->pos = parser->json_string;
+	parser->tokens = NULL;
+	parser->last_token = -1;
+	parser->toknext = 0;
+	parser->tokstack = NULL;
+	parser->stack_level = -1;
+	parser->max_stack_depth = -1;
+	parser->parent_tok = NULL;
+
+	if (json_string == NULL) {
+		return JS_ERROR_INVAL;
+	}
+
+	if (parser->json_string == NULL) {
+		return JS_ERROR_NOMEM;
+	}
+	strcpy(parser->json_string, json_string);
+
+	if ((c = *(parser->pos)) == '\0') {
+		return JS_ERROR_PART;
+	}
+
+	js_discard_whitespace(parser);
+	r = js_parse_value(parser, &token);
+	if (r != JS_SUCCESS) {
+		return r;
+	}
+	js_discard_whitespace(parser);
+	if (*(parser->pos) != '\0') {
+		return JS_ERROR_INVAL;
+	}
+	return JS_SUCCESS;
+}
+
+/**
+ * Free up the allocated memory in a parser structure
+ */
+void
+json_free_parser(js_parser *parser)
+{
+	if (parser->json_string != NULL) free(parser->json_string);
+	if (parser->tokens != NULL) free(parser->tokens);
+	if (parser->tokstack != NULL) free(parser->tokstack);
+}
+
+/**
+ * Constants for the JSON pretty printer
+ */
+#define BUF_QUANTUM 1000
+#define INDENT_QUANTUM 10
+
+/*
+ * Building output string for JSON pretty printer.
+ * Dynamically expands buffer if necessary.
+ */
+static jserr_t
+js_put_buf(char **buf, int*buf_len, char **outptr, int *outindx, char *str, int length)
+{
+	if ((*outindx + length + 1) > *buf_len) {
+		*buf_len += BUF_QUANTUM;
+		*buf = (char *)realloc(*buf, *buf_len);
+		if (*buf == NULL) return JS_ERROR_NOMEM;
+		*outptr = *buf + *outindx;
+	}
+	strncpy(*outptr, str, length);
+	*outindx += length;
+	*outptr += length;
+	**outptr = '\0';
+	return JS_SUCCESS;
+}
+/**
+ * Shorthand for adding strings to output buffer.
+ */
+#define JS_PUT_BUF(s,l) { if (js_put_buf(buf, buf_len, &outptr, &outindx, s, l) != JS_SUCCESS) return JS_ERROR_NOMEM; }
+
+/**
+ * Pretty printer for JSON strings parsed by json_parser.
+ */
+jserr_t
+json_pretty_print(js_parser *parser, char**buf, int *buf_len,
+				  int indent, char *item_sep, char *key_sep)
+{
+	int level = 0;
+	int max_level = 0;
+	int level_inc;
+	int no_nl = (indent < 0);
+	int i, tok_index;
+	int outindx = 0;
+	char *outptr = NULL;
+	char *prefix = NULL;
+	int curr_prfx_len = 0;
+	char *p, *s, *e;
+	jstok_t *tok;
+
+	if (item_sep == NULL) {
+		item_sep = ", ";
+	}
+	if (key_sep == NULL) {
+		key_sep = ": ";
+	}
+	*buf = NULL;
+	*buf_len = 0;
+
+
+	if ((parser->json_string == NULL) || (parser->tokens == NULL)
+			|| (parser->toknext > parser->last_token)) {
+		return JS_ERROR_INVAL;
+	}
+
+	for (tok_index = 0 ; tok_index < parser->toknext; tok_index++) {
+		tok = &parser->tokens[tok_index];
+		switch (tok->type) {
+		case JS_OBJECT:
+			s = e = "{";
+			level_inc = (tok->child != NULL) ? 1 : 0;
+			break;
+
+		case JS_ARRAY:
+			s = e = "[";
+			level_inc = (tok->child != NULL) ? 1 : 0;
+			break;
+
+		case JS_VALPAIR:
+			s = e = NULL;
+			level_inc = 0;
+			break;
+
+		case JS_STRING:
+			// Includes the quotes for output
+			s = tok->start - 1;
+			e = tok->end + 1;
+			level_inc = 0;
+			break;
+		case JS_NUMBER:
+		case JS_TRUE:
+		case JS_FALSE:
+		case JS_NULL:
+			s = tok->start;
+			e = tok->end;
+			level_inc = 0;
+			break;
+		default:
+			s = e = "?";
+			level_inc = 0;
+			break;
+		}
+		/**
+		 * Ensure there is a long enough prefix string for new indent level.
+		 */
+		if ((indent > 0) && ((level_inc + level) > max_level)) {
+			max_level += INDENT_QUANTUM;
+			i = indent * max_level;
+			prefix = (char *)realloc(prefix, i + 1);
+			if (prefix == NULL) {
+				return JS_ERROR_NOMEM;
+			}
+			p = prefix;
+			while (i-- > 0) {
+				*p++ = ' ';
+			}
+			*p = '\0';
+		}
+		/*
+		 * Generate the output for this token (if any)
+		 * - VALPAIRs don't get output explicitly.
+		 * - Objects and Arrays just print their opening delimiter
+		 * - Values produce what was recorded.
+		 * Then add a separator and newline if required
+		 */
+		if (s != NULL) {
+			/* Add initial indent if requested and not value part of VALPAIR */
+			if ((indent > 0) && (tok->parent != NULL) &&
+					!((tok->parent->type == JS_VALPAIR) && (tok->sibling == NULL))) {
+				JS_PUT_BUF(prefix, indent * level);
+			}
+			/* Output the actual item contents*/
+			JS_PUT_BUF(s, e - s + 1);
+			/**
+			 * Decide whether to output item separator and/or new line.
+			 * - If we are dealing with a VALPAIR:
+			 *   - The name has a key separator but no new line ever
+			 *   - The value part has an item separator if the whole VALPAIR
+			 *     i.e., its parent token, has a sibling and the value token
+			 *     is not an array or object (the separator is postponed to
+			 *     the closing delimiter of the object or array.
+			 * - For Objects and Arrays there is never a separator with the
+			 *   opening delimiter.
+			 * - For Values, if the token has a sibling then output an iterm separator
+			 * A newline is added except for the VALPAIR name case if indent >=0
+			 */
+			if ((tok->parent != NULL) && (tok->parent->type == JS_VALPAIR)) {
+				if (tok->sibling != NULL) {
+					/* The name */
+					JS_PUT_BUF(key_sep, strlen(key_sep));
+				} else if ((tok->parent->sibling != NULL) &&
+						!((tok->type == JS_ARRAY) || (tok->type == JS_OBJECT))) {
+					/**
+					 *  A value that isn't an Array or Object and isn't the last
+					 *  in the enclosing Object.
+					 */
+					JS_PUT_BUF(item_sep, strlen(item_sep));
+					if (!no_nl) JS_PUT_BUF("\n", 1);
+				}else {
+					/**
+					 * All Arrays and Objects as values
+					 * Other values that come last in the enclosing Object.
+					 */
+					if (!no_nl) JS_PUT_BUF("\n", 1);
+				}
+			} else if ((!((tok->type == JS_OBJECT) || (tok->type == JS_ARRAY))) &&
+							(tok->sibling != NULL)) {
+				/**
+				 * Values other than Objects and Arrays not last in the enclosing Array.
+				 */
+				JS_PUT_BUF(item_sep, strlen(item_sep));
+				if (!no_nl) JS_PUT_BUF("\n", 1);
+			} else {
+				if (!no_nl) JS_PUT_BUF("\n", 1);
+			}
+		}
+		/**
+		 * Indent some more when starting a non-empty Array or Object
+		 */
+		level += level_inc;
+		/*
+		 * Deal with empty Arrays and Objects
+		 * Unwind the level stack after handling all items in an Array or Object
+		 * Don't do any of this if the current item has children.
+		 */
+		if (tok->child == NULL) {
+			/*
+			 * Special case for empty Arrays and Objects (i.e. that have no children)
+			 * In this case don't have to unindent as extra indent was suppressed above.
+			 */
+			if ((tok->type == JS_OBJECT) || (tok->type == JS_ARRAY)) {
+				if (indent > 0) {
+					JS_PUT_BUF(prefix, indent *level);
+				}
+				/**
+				 *  Output the closing delimiter and separator if required.
+				 */
+				if (tok->type == JS_OBJECT) JS_PUT_BUF("}", 1);
+				if (tok->type == JS_ARRAY) JS_PUT_BUF("]", 1);
+				if ((tok->sibling != NULL) ||
+						((tok->parent != NULL) && (tok->parent->type == JS_VALPAIR) &&
+								(tok->parent->sibling != NULL))){
+					JS_PUT_BUF(item_sep, strlen(item_sep));
+				}
+				if (!no_nl) JS_PUT_BUF("\n", 1);
+			}
+			/*
+			 * Unwind the stack after processing the last item in a VALPAIR,
+			 * Object or Array.  May go up several levels if this is the last
+			 * item in several nested levels.
+			 * Output closing delimiter for Arrays and Objects that are terminated.
+			 * Pass silently over VALPAIRS that terminate.
+			 */
+			while (tok->sibling == NULL){
+				tok = tok->parent;
+				if (tok == NULL) break;
+				if ((tok->type == JS_OBJECT) || (tok->type == JS_ARRAY)) {
+					level -= 1;
+					if (indent > 0) {
+						JS_PUT_BUF(prefix, indent *level);
+					}
+					if (tok->type == JS_OBJECT) JS_PUT_BUF("}", 1);
+					if (tok->type == JS_ARRAY) JS_PUT_BUF("]", 1);
+					if ((tok->sibling != NULL) ||
+							((tok->parent != NULL) && (tok->parent->type == JS_VALPAIR) &&
+									(tok->parent->sibling != NULL))){
+						JS_PUT_BUF(item_sep, strlen(item_sep));
+					}
+					if (!no_nl) JS_PUT_BUF("\n", 1);
+				}
+			}
+		}
+	}
+	return JS_SUCCESS;
+}
+
diff -r 52e2b403edd4 -r 00bddbb095de applib/json.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/applib/json.h	Fri Jan 04 17:01:21 2013 +0000
@@ -0,0 +1,134 @@
+/*
+ *    Copyright 2010 - 2012 Trinity College Dublin
+ *    Copyright 2012 Folly Consulting Ltd
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+#ifndef JSON_H_
+#define JSON_H_
+
+/**
+ * JSON type identifier. Basic types are:
+ * 	o Object
+ * 	o Array
+ *  o Value Pair
+ * 	o String
+ * 	o Number
+ *  o Boolean (true/false)
+ *  o null
+ */
+typedef enum {
+	JS_UNUSED = 0,
+	JS_OBJECT = 1,
+	JS_ARRAY = 2,
+	JS_VALPAIR = 3,
+	JS_STRING = 4,
+	JS_NUMBER = 5,
+	JS_TRUE = 6,
+	JS_FALSE = 7,
+	JS_NULL = 8
+} jstype_t;
+
+/**
+ * Various fixed strings
+ */
+#define JS_TRUE_STR "true"
+#define JS_FALSE_STR "false"
+#define JS_NULL_STR "null"
+
+#define JS_NUM_DELIMS " ,]}"
+
+typedef enum {
+	/* Not enough tokens were provided */
+	JS_ERROR_NOMEM = -1,
+	/* Invalid character inside JSON string */
+	JS_ERROR_INVAL = -2,
+	/* The string is not a full JSON packet, more bytes expected */
+	JS_ERROR_PART = -3,
+	/* Everything was fine */
+	JS_SUCCESS = 0
+} jserr_t;
+
+/**
+ * JSON token description.
+ * @param		type	type (object, array, string etc.)
+ * @param		start	start position in JSON data string
+ * @param		end		end position in JSON data string
+ */
+typedef struct JStok_t {
+	jstype_t type;
+	char *start;
+	char *end;
+	int size;
+    struct JStok_t *child;
+    struct JStok_t *sibling;
+    struct JStok_t *parent;
+} jstok_t;
+
+/**
+ * Number of tokens to allocate at a time.
+ */
+#define TOK_QUANTUM 100
+
+/**
+ * Number of token stack levels to allocate at a time
+ */
+#define STK_QUANTUM 10
+
+/**
+ * JSON parser. Contains an array of token blocks available. Also stores
+ * the string being parsed now and current position in that string
+ */
+typedef struct {
+	char *json_string; /* pointer to start of string being parsed */
+	char *pos; /* current pointer into the JSON string */
+	jstok_t *tokens; /* Array of parsed tokens */
+	int last_token; /* Index of last malloc'ed token in array */
+	int toknext; /* next token to allocate */
+	jstok_t **tokstack; /* stack of superior token nodes, e.g parent object or array */
+	int stack_level; /* current bottom of stack index */
+	int max_stack_depth; /* number of levels available in the tokstack */
+	jstok_t *parent_tok;
+} js_parser;
+
+/**
+ * Parse a string containing a JSON specification 'object'.  This function
+ * accepts essentially the same version of slightly expanded JSON that the
+ * Python json module accepts.  The differences from base specification in
+ * RFC 4627 are that the parser accepts single values on their own as well
+ * as either an object or an array as the 'top level' item.  The parser
+ * however doesn't accept infinity of Not a Number as values for Numbers,
+ * unlike the Python parser.  The output is created as
+ */
+extern jserr_t json_parser(js_parser *parser, const char *json_string);
+
+/*
+ * Free malloc'd memory used by a JSON parser operation.
+ */
+extern void json_free_parser(js_parser *parser);
+
+/*
+ * Pretty print a parsed JSON structure.  Also following the Python model
+ * Allocates its own buffer and returns the location and length.
+ * If indent is negative, no newlines are output.  Otherwise structure levels
+ * are indented by one extra 'indent' per level.  If item_sep and/or key_sep
+ * are NULL, they default to ', ' and ': ' respectively.
+ * The parser should have been primed by parsing a valid JSON string (and not
+ * freed in between times).
+ */
+extern jserr_t json_pretty_print(js_parser *parser, char**buf, int *buf_len,
+								   int indent, char *item_sep, char *key_sep);
+
+
+#endif /* JSON_H_ */
diff -r 52e2b403edd4 -r 00bddbb095de applib/mkrandstr.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/applib/mkrandstr.c	Fri Jan 04 17:01:21 2013 +0000
@@ -0,0 +1,53 @@
+/*
+ *    Copyright 2010 - 2012 Trinity College Dublin
+ *    Copyright 2012 Folly Consulting Ltd
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include <dtn-config.h>
+#endif
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <time.h>
+
+#include "mkrandstr.h"
+
+static unsigned int seed = 0;
+
+static char random_alnum_char(void)
+{
+	int c;
+	while (!isalnum(c = (char)((rand() % 74) + '0')));
+	return c;
+}
+
+void make_random_string(char *buf)
+{
+	int len;
+	char *bp = buf;
+	if (seed == 0) {
+		seed = (unsigned int)time(NULL);
+		srand(seed);
+	}
+	len = ((int)random_alnum_char())>>2;
+
+	while (len-- > 0) {
+		*bp++ = random_alnum_char();
+	}
+
+	*bp = '\0';
+}
+
diff -r 52e2b403edd4 -r 00bddbb095de applib/mkrandstr.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/applib/mkrandstr.h	Fri Jan 04 17:01:21 2013 +0000
@@ -0,0 +1,26 @@
+/*
+ *    Copyright 2010 - 2012 Trinity College Dublin
+ *    Copyright 2012 Folly Consulting Ltd
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+/*
+ * Generate a random string of alphanumeric characters between
+ * 12 and 30 characters long for use as NetInf message ID strings
+ * or any other random identification purposes.
+ *
+ * Supply a buffer of at least 31 characters long to receive the new string.
+ * Seeds itself with the current time in seconds.
+ * There is therefore a small chance that duplicate sequences will be generated
+ */
+extern void make_random_string(char *buf);
diff -r 52e2b403edd4 -r 00bddbb095de apps/dtnpublish/dtnpublish.c
--- a/apps/dtnpublish/dtnpublish.c	Mon Nov 19 11:58:18 2012 +0000
+++ b/apps/dtnpublish/dtnpublish.c	Fri Jan 04 17:01:21 2013 +0000
@@ -30,6 +30,9 @@
 #include <fcntl.h>
 #include "dtn_api.h"
 #include "sdnv-c.h"
+#include "bpq_api.h"
+#include "json.h"
+#include "mkrandstr.h"
 
 #define BUFSIZE 16
 #define BLOCKSIZE 8192
@@ -68,8 +71,10 @@
     fprintf(stderr, " -r  < eid > reply to endpoint\n");
     fprintf(stderr, " -p  < filename > payload filename\n");
     fprintf(stderr, " -n  < cache name > typically ni: name for payload\n");
+    fprintf(stderr, " -M  < metadata > a string representing a JSON object\n");
     fprintf(stderr, " -o  < seconds > report receiver timeout\n");
     fprintf(stderr, " -e  < seconds > bundle expiry time\n");
+    fprintf(stderr, " -I  < string > query identifier (auto-generated if not supplied)\n");
     fprintf(stderr, " -a  <number of reports expected to wait for>\n");
     fprintf(stderr, " -P  < bulk | normal | expedited | reserved > priority\n");
     fprintf(stderr, " -D  request end-to-end delivery receipt\n");
@@ -101,6 +106,8 @@
     char * reply_eid_name,              // r
     char * payload_file,                // p
     char * cache_name,                  // n
+    char * metadata,                    // M
+    char * query_id,					// I
     dtn_timeval_t * timeout,            // o
     dtn_timeval_t * bundle_expiry,      // e
     int * num_reports,					// a
@@ -119,10 +126,12 @@
     memset(reply_eid_name,  0, sizeof(char) * PATH_MAX);
     memset(payload_file,    0, sizeof(char) * PATH_MAX);
     memset(cache_name,      0, sizeof(char) * PATH_MAX);
+    memset(metadata,        0, sizeof(char) * PATH_MAX);
+    memset(query_id,        0, sizeof(char) * PATH_MAX);
 
     while( !done )
     {
-        c = getopt(argc, argv, "s:d:r:p:n:o:e:a:P:DXFRcC1NWwhHv");
+        c = getopt(argc, argv, "s:d:r:p:n:M:o:e:I:a:P:DXFRcC1NWwhHv");
         switch(c)
         {
         case 's':            
@@ -140,6 +149,12 @@
         case 'n':
             strncpy(cache_name, optarg, PATH_MAX);
             break;
+        case 'M':
+            strncpy(metadata, optarg, PATH_MAX);
+            break;
+        case 'I':
+            strncpy(query_id, optarg, PATH_MAX);
+            break;
         case 'o':
             *timeout = atoi(optarg);
             break;
@@ -231,9 +246,12 @@
     const char * dest_eid_name,
     const char * payload_file,
     const char * cache_name,
+    const char * metadata,
+    const char * query_id,
     dtn_timeval_t timeout,
     dtn_timeval_t bundle_expiry,
-    int num_reports)
+    int num_reports,
+    int verbose)
 {
 #define REQUIRE(test, err_msg) \
     if(!test) { \
@@ -242,6 +260,10 @@
         exit(1); \
     }
 
+	js_parser p;
+	char *pp_buf;
+	int pp_len;
+
 	REQUIRE(strlen(src_eid_name) > 0, "-s <src eid> required\n");
 	REQUIRE(strlen(dest_eid_name) > 0, "-d <dest eid> required\n");
 	REQUIRE(strlen(payload_file) > 0, "-p <payload filename> required\n");
@@ -249,6 +271,23 @@
 	REQUIRE(timeout > 0, "-o <timeout> must be a positive integer\n");
 	REQUIRE(bundle_expiry > 0, "-e <expiry> must be a positive integer\n");
 	REQUIRE(num_reports > 0, "-a <number of reports expected> must be a positive integer\n");
+	if (strlen(metadata) > 0) {
+		REQUIRE(json_parser(&p, metadata) == JS_SUCCESS,
+				"-m <metadata> must be a valid JSON object string\n");
+		if (verbose) {
+			printf("Metadata:\n");
+			json_pretty_print(&p, &pp_buf, &pp_len, 4, NULL, NULL);
+			printf(pp_buf);
+		}
+		json_free_parser(&p);
+	}
+	if (strlen(query_id) == 0) {
+		// Generate our own query id
+		make_random_string(query_id);
+	}
+	if (verbose) {
+		printf("Query ID: %s\n", query_id);
+	}
 
     return DTN_SUCCESS;
 #undef REQUIRE
@@ -292,7 +331,7 @@
 
     return DTN_SUCCESS;
 }
-
+#if 0
 /*******************************************************************************
 * parse eid:
 *  
@@ -335,6 +374,9 @@
 *   Source EID length			SDNV
 *   Source EID 					n-bytes
 *
+*   Query ID length     		SDNV
+*   Query ID            		n-bytes
+*
 *   Query value length     		SDNV
 *   Query value            		n-bytes
 *
@@ -350,7 +392,7 @@
     size_t buf_len,
     int verbose)
 {
-    int j=0, q_encoding_len, f_encoding_len, encoding_len;
+    int j=0, i_encoding_len, q_encoding_len, f_encoding_len, encoding_len;
     u_int i=0, k=0;
     u_char encoding[PATH_MAX];
 
@@ -397,31 +439,51 @@
 		memcpy(&(buf[i]), bpq->original_id.source.uri, bpq->original_id.source_len);
 		i += bpq->original_id.source_len;
 	} else {
+		fprintf (stderr, "Error encoding Source EID value\n");
+		return -1;
+	}
+
+
+	// Query ID length (SDNV)
+	if ( (i_encoding_len = sdnv_encode (bpq->query_id.query_id_len,
+										encoding, PATH_MAX)) == -1 ) {
+		fprintf (stderr, "Error encoding query ID len\n");
+		return -1;
+	} else {
+		for (j=0; i<buf_len && j<i_encoding_len; ++j)
+			buf[i++] = encoding[j];
+	}
+
+	// Query ID n-bytes
+	if ( (i + bpq->query_id.query_id_len) < buf_len ) {
+		memcpy(&(buf[i]), bpq->query_id.query_id_val, bpq->query_id.query_id_len);
+		i += bpq->query_id.query_id_len;
+	} else {
+		fprintf (stderr, "Error encoding query ID value\n");
+		return -1;
+	}
+
+
+	// Query length (SDNV)
+	if ( (q_encoding_len = sdnv_encode (bpq->query.query_len,
+										encoding, PATH_MAX)) == -1 ) {
+		fprintf (stderr, "Error encoding query len\n");
+		return -1;
+	} else {
+		for (j=0; i<buf_len && j<q_encoding_len; ++j)
+			buf[i++] = encoding[j];
+	}
+
+	// Query value n-bytes
+	if ( (i + bpq->query.query_len) < buf_len ) {
+		memcpy(&(buf[i]), bpq->query.query_val, bpq->query.query_len);
+		i += bpq->query.query_len;
+	} else {
 		fprintf (stderr, "Error encoding query value\n");
 		return -1;
 	}
 
 
-    // Query length (SDNV)
-    if ( (q_encoding_len = sdnv_encode (bpq->query.query_len,
-    									encoding, PATH_MAX)) == -1 ) {
-    	fprintf (stderr, "Error encoding query len\n");
-        return -1;
-    } else {
-    	for (j=0; i<buf_len && j<q_encoding_len; ++j)
-    		buf[i++] = encoding[j];
-    }
-
-    // Query value n-bytes
-    if ( (i + bpq->query.query_len) < buf_len ) {
-    	memcpy(&(buf[i]), bpq->query.query_val, bpq->query.query_len);
-    	i += bpq->query.query_len;
-    } else {
-    	fprintf (stderr, "Error encoding query value\n");
-    	return -1;
-    }
-
-
     // number of fragments  SDNV
     if ( (f_encoding_len = sdnv_encode (bpq->fragments.num_frag_returned,
     									encoding, PATH_MAX)) == -1 ){
@@ -469,6 +531,10 @@
         fprintf (stdout, "       source eid: %s\n",
         		       bpq->original_id.source.uri);
 
+        fprintf (stdout, "     query ID len: %d\n", bpq->query.query_len);
+        fprintf (stdout, "   i_encoding_len: %d\n", q_encoding_len);
+        fprintf (stdout, "         query ID: %s\n", bpq->query.query_val);
+
         fprintf (stdout, "        query len: %d\n", bpq->query.query_len);
         fprintf (stdout, "   q_encoding_len: %d\n", q_encoding_len);
         fprintf (stdout, "        query val: %s\n", bpq->query.query_val);
@@ -492,6 +558,9 @@
 *   Source EID length			SDNV
 *   Source EID 					n-bytes
 *
+*   Query ID length     		SDNV
+*   Query ID            		n-bytes
+*
 *   Query value length     		SDNV
 *   Query value            		n-bytes
 *
@@ -508,7 +577,7 @@
     int verbose)
 {
     u_int i=0, j=0;
-    int q_decoding_len, f_decoding_len, decoding_len;
+    int q_decoding_len, f_decoding_len, i_decoding_len, decoding_len;
 
     // BPQ-kind             1-byte
     if (i<buf_len) bpq->kind = (u_int) buf[i++];
@@ -554,6 +623,20 @@
 		return -1;
     }
 
+    // BPQ-ID-length        SDNV
+    if ( (i_decoding_len = sdnv_decode (&(buf[i]),
+    									buf_len - i,
+    									(u_int64_t*)&(bpq->query_id.query_id_len))) == -1 ) {
+        fprintf (stderr, "Error decoding BPQ-ID-length\n");
+        return -1;
+    }
+    i += i_decoding_len;
+
+    // BPQ-ID               n-bytes
+    if (i<buf_len) bpq->query_id.query_id_val = (char*)&(buf[i]);
+    	i += bpq->query_id.query_id_len;
+
+
     // BPQ-value-length     SDNV
     if ( (q_decoding_len = sdnv_decode (&(buf[i]),
     									buf_len - i,
@@ -615,7 +698,11 @@
         fprintf (stdout, "       source eid: %s\n",
         		 bpq->original_id.source.uri);
 
-        fprintf (stdout, "        query len: %d\n", bpq->query.query_len);
+        fprintf (stdout, "     query ID len: %d\n", bpq->query_id.query_id_len);
+        fprintf (stdout, "   i_decoding_len: %d\n", i_decoding_len);
+        fprintf (stdout, "     query ID val: %s\n", bpq->query_id.query_id_val);
+
+       fprintf (stdout, "        query len: %d\n", bpq->query.query_len);
         fprintf (stdout, "   q_decoding_len: %d\n", q_decoding_len);
         fprintf (stdout, "        query val: %s\n", bpq->query.query_val);
 
@@ -628,7 +715,7 @@
 
 /*******************************************************************************
 * send bpq:
-* build a bundle with a BPQ extension block conatining the name to be associated
+* build a bundle with a BPQ extension block containing the name to be associated
 * with the file given as a payload and send it to the destination (which may be
 * totally arbitrary - the intention is to publish the file and have it cached
 * where it passes.
@@ -639,6 +726,8 @@
     const dtn_endpoint_id_t * dest_eid,
     const dtn_endpoint_id_t * reply_eid,
     char * cache_name,
+    char * query_id,
+    char * metadata,
     char * payload_file,
     int bundle_expiry,
     dtn_bundle_priority_t  priority,
@@ -646,17 +735,20 @@
     int verbose)
 {
     int  ret = 0;
+    int  enc_len;
     char buf [PATH_MAX];
+    char mbuf [PATH_MAX];
     size_t buf_len = 0;
     dtn_bundle_id_t                 bundle_id;
     dtn_bundle_spec_t               bundle_spec;
-    dtn_extension_block_t           bpq_block;
+    dtn_extension_block_t           bpq_block, metadata_block;
     dtn_bpq_extension_block_data_t  bpq_block_data;
     dtn_bundle_payload_t            payload;
 
     memset(buf,             0, PATH_MAX);
     memset(&bundle_spec,    0, sizeof(dtn_bundle_spec_t));
     memset(&bpq_block,      0, sizeof(dtn_extension_block_t));
+    memset(&metadata_block, 0, sizeof(dtn_extension_block_t));
     memset(&bpq_block_data, 0, sizeof(dtn_bpq_extension_block_data_t));
     memset(&payload,        0, sizeof(dtn_bundle_payload_t));
     
@@ -669,6 +761,9 @@
     bpq_block_data.original_id.source = *src_eid;
     bpq_block_data.original_id.source_len = strlen(src_eid->uri);
 
+    bpq_block_data.query_id.query_id_len = strlen(query_id) + 1;     // include the null char at the end
+    bpq_block_data.query_id.query_id_val = query_id;
+
     bpq_block_data.query.query_len = strlen(cache_name) + 1;     // include the null char at the end
     bpq_block_data.query.query_val = cache_name;
     bpq_block_data.fragments.num_frag_returned = 0;
@@ -678,11 +773,32 @@
     buf_len = bpq_to_char_array(&bpq_block_data, buf, PATH_MAX, verbose);
 
     // set the bpq block
-    bpq_block.type = DTN_BPQ_BLOCK_TYPE;
+    bpq_block.type = QUERY_EXTENSION_BLOCK;
     bpq_block.flags = BLOCK_FLAG_REPLICATE;
     bpq_block.data.data_len = buf_len;
     bpq_block.data.data_val = buf;
     
+    /**
+     * If there is metadata supplied, add a metadata block to bundle
+     */
+    if (strlen(metadata) > 0){
+		// Put the ontology for the metadata st start of buffer
+        if ( (enc_len = sdnv_encode (JSON_METADATA_BLOCK, mbuf, PATH_MAX)) == -1 ) {
+        	fprintf (stderr, "Error encoding metadata ontology\n");
+        	return -1;
+        }
+
+        // Copy in the actual metadata
+        strncpy(&mbuf[enc_len], metadata, (PATH_MAX - enc_len));
+
+		// set the metadata block
+		metadata_block.type = METADATA_BLOCK;
+		metadata_block.flags = BLOCK_FLAG_REPLICATE;
+		metadata_block.data.data_len = enc_len + strlen(metadata) + 1;
+		metadata_block.data.data_val = mbuf;
+
+    }
+
     // set the payload (expected to be file path)
     dtn_set_payload(&payload, DTN_PAYLOAD_FILE, payload_file, strlen(payload_file));
 
@@ -703,6 +819,12 @@
     bundle_spec.blocks.blocks_len = 1;
     bundle_spec.blocks.blocks_val = &bpq_block;
 
+    // set the bundle metadata if there is any (whole structure was zeroed initially)
+    if (strlen(metadata) > 0){
+    	bundle_spec.metadata.metadata_len = 1;
+    	bundle_spec.metadata.metadata_val = &metadata_block;
+    }
+
     // send the bundle, bpq extension and empty payload
     if (verbose) fprintf(stdout, "Sending bundle to: %s (options %x)\n",
 					     dest_eid->uri, delivery_options);
@@ -750,6 +872,7 @@
 			break;
 	}
 }
+#endif
 /*******************************************************************************
 * await_reports:  if request specified reports wanted and we ask to wait for
 * them - loop waiting for reports to arrive up to timeout.
@@ -820,6 +943,8 @@
     char reply_eid_name[PATH_MAX];
     char payload_file[PATH_MAX];
     char cache_name[PATH_MAX];
+    char metadata[PATH_MAX];
+    char query_id[PATH_MAX];
     dtn_timeval_t timeout = DTN_TIMEOUT_INF;    //forever
     dtn_timeval_t bundle_expiry = 3600;         //one hour
     int num_reports = 1;
@@ -837,6 +962,8 @@
     memset( reply_eid_name, 0, sizeof(char) * PATH_MAX );
     memset( payload_file,   0, sizeof(char) * PATH_MAX );
     memset( cache_name,     0, sizeof(char) * PATH_MAX );
+    memset( metadata,       0, sizeof(char) * PATH_MAX );
+    memset( query_id,       0, sizeof(char) * PATH_MAX );
 
     parse_options(argc, argv,
         src_eid_name,
@@ -844,6 +971,8 @@
         reply_eid_name,
         payload_file,
         cache_name,
+        metadata,
+        query_id,
         &timeout,
         &bundle_expiry,
         &num_reports,
@@ -858,9 +987,12 @@
         dest_eid_name,
         payload_file,
         cache_name,
+        metadata,
+        query_id,
         timeout,
         bundle_expiry,
-        num_reports);
+        num_reports,
+        verbose);
 
     // open the ipc handle
     if (verbose) printf("opening connection to dtn router...\n");
@@ -905,12 +1037,13 @@
         dtn_close(handle); \
         exit(1); \
     }
-    TRY( send_bpq(handle, &src_eid, &dest_eid, &reply_eid, cache_name,
-                      payload_file, bundle_expiry, priority,
-                      delivery_options, verbose), "error publishing file\n" );
+    TRY( send_bpq(handle, BPQ_BLOCK_KIND_PUBLISH, &src_eid, &dest_eid, &reply_eid,
+    		      cache_name, query_id, metadata, payload_file, BPQ_MATCHING_RULE_EXACT,
+    		      bundle_expiry, priority, delivery_options, verbose),
+    		      "error publishing file\n" );
     if (wait_for_report) {
     	TRY( await_reports(handle, timeout, num_reports),
-    			"error receiving expected reports");
+    		 "error receiving expected reports");
     }
 
 
diff -r 52e2b403edd4 -r 00bddbb095de apps/dtnquery/dtnquery.c
--- a/apps/dtnquery/dtnquery.c	Mon Nov 19 11:58:18 2012 +0000
+++ b/apps/dtnquery/dtnquery.c	Fri Jan 04 17:01:21 2013 +0000
@@ -29,6 +29,9 @@
 #include <fcntl.h>
 #include "dtn_api.h"
 #include "sdnv-c.h"
+#include "bpq_api.h"
+#include "json.h"
+#include "mkrandstr.h"
 
 #define BUFSIZE 16
 #define BLOCKSIZE 8192
@@ -71,8 +74,11 @@
     fprintf(stderr, " -r  < eid > reply to endpoint\n");
     fprintf(stderr, " -f  < filename > response filename\n");
     fprintf(stderr, " -q  < query > query or matching file\n");
+    fprintf(stderr, " -M  < metadata > a string representing a JSON object\n");
+    fprintf(stderr, " -g  < metadata filename > filename for response metadata\n");
     fprintf(stderr, " -t  < literal | base64 | file > query type\n");
     fprintf(stderr, " -u  < exact > matching rule\n");
+    fprintf(stderr, " -I  < string > query identifier (auto-generated if not supplied)\n");
     fprintf(stderr, " -m  < send | receive | both > mode\n");
     fprintf(stderr, " -n  < count > number of bundles to recv\n");
     fprintf(stderr, " -o  < seconds > receiver timeout\n");
@@ -120,7 +126,7 @@
 
     memset(line, 0, sizeof(char) * PATH_MAX);
     
-    if (verbose) fprintf(stdout, "openning matching file...\n");
+    if (verbose) fprintf(stdout, "opening matching file...\n");
     file = fopen(filename, "r");
     if (file == NULL) {
         fprintf(stderr, "Error opening file: %s", filename);
@@ -176,6 +182,9 @@
     char * dest_eid_name,               // d
     char * reply_eid_name,              // r
     char * filename,                    // f
+    char * metadata,					// M
+    char * metadata_fn,					// g
+    char * query_id,					// I
     char * query,                       // q
     int * query_type,                   // t
     int * matching_rule,                // u
@@ -201,13 +210,16 @@
     memset(dest_eid_name,   0, sizeof(char) * PATH_MAX);
     memset(reply_eid_name,  0, sizeof(char) * PATH_MAX);
     memset(filename,        0, sizeof(char) * PATH_MAX);
+    memset(metadata,        0, sizeof(char) * PATH_MAX);
+    memset(metadata_fn,     0, sizeof(char) * PATH_MAX);
+    memset(query_id,        0, sizeof(char) * PATH_MAX);
     memset(query,           0, sizeof(char) * PATH_MAX);
     memset(matching_file,   0, sizeof(char) * PATH_MAX);
     memset(reg_fail_script, 0, sizeof(char) * PATH_MAX);
 
     while( !done )
     {
-        c = getopt(argc, argv, "s:d:f:q:t:r:u:m:n:o:e:i:E:A:S:P:DXFcC1NWvhH");
+        c = getopt(argc, argv, "s:d:f:q:t:r:u:m:M:g:n:o:e:i:E:A:S:P:DXFcC1NWvhH");
         switch(c)
         {
         case 's':            
@@ -225,6 +237,15 @@
         case 'q':            
             strncpy(query, optarg, PATH_MAX);
             break;
+        case 'M':
+            strncpy(metadata, optarg, PATH_MAX);
+            break;
+        case 'g':
+            strncpy(metadata_fn, optarg, PATH_MAX);
+            break;
+        case 'I':
+            strncpy(query_id, optarg, PATH_MAX);
+            break;
         case 't':
             if (!strcasecmp(optarg, "literal")) {
                 *query_type = DTN_BPQ_LITERAL;
@@ -390,11 +411,14 @@
 validate_options(const char * src_eid_name,
     const char * dest_eid_name,
     const char * reply_eid_name,
+    const char * metadata,
+    char * query_id,
     const char * query,
     int query_type,
     int matching_rule,
     int mode,
-    dtn_timeval_t bundle_expiry)
+    dtn_timeval_t bundle_expiry,
+    int verbose)
 {
 //todo: add new options
 #define REQUIRE(test, err_msg) \
@@ -404,6 +428,10 @@
         exit(1); \
     }
 
+	js_parser p;
+	char *pp_buf = " ";
+	int pp_len;
+
     switch (mode)
     {
     case DTN_BPQ_SEND:  //requires src, dest, query
@@ -436,6 +464,31 @@
     REQUIRE(matching_rule == BPQ_MATCHING_RULE_EXACT,
          "-u <matching rule> invalid rule\n");
     REQUIRE(bundle_expiry > 0, "-e <expiry> must be a positive integer\n");
+	if (strlen(metadata) > 0) {
+		REQUIRE(json_parser(&p, metadata) == JS_SUCCESS,
+				"-m <metadata> must be a valid JSON object string\n");
+		if (verbose) {
+			printf("Metadata:\n");
+			json_pretty_print(&p, &pp_buf, &pp_len, 4, NULL, NULL);
+			printf(pp_buf);
+		}
+		json_free_parser(&p);
+		if (mode == DTN_BPQ_RECV){
+			printf("Warning: metadata ignored when mode is DTN_BPQ_RECV");
+		}
+	}
+	if (strlen(query_id) == 0) {
+		if (mode == DTN_BPQ_RECV) {
+			printf("Warning: query_id will not be checked as none specified.");
+		} else {
+			// Generate our own query id
+			make_random_string(query_id);
+		}
+	}
+	if (verbose) {
+		printf("Query ID: %s (%d)\n", (strlen(query_id) > 0) ? query_id : "(none)",
+				                       strlen(query_id));
+	}
 
     return DTN_SUCCESS;
 #undef REQUIRE
@@ -507,7 +560,7 @@
 
     return DTN_SUCCESS;
 }
-
+#if 0
 /*******************************************************************************
 * parse eid:
 *  
@@ -555,6 +608,8 @@
     ssize_t bytes_read;
     struct stat fileinfo;
 
+    // Try a rename first - will fail if
+
     if ( (src_fd = open(payload.filename.filename_val, O_RDONLY)) < 0) {
         fprintf(stderr, "error opening payload file for reading '%s': %s\n",
                 payload.filename.filename_val, strerror(errno));
@@ -945,7 +1000,7 @@
     buf_len = bpq_to_char_array(&bpq_block_data, buf, PATH_MAX, verbose);
 
     // set the bpq block
-    bpq_block.type = DTN_BPQ_BLOCK_TYPE;
+    bpq_block.type = QUERY_EXTENSION_BLOCK;
     bpq_block.flags = BLOCK_FLAG_REPLICATE;
     bpq_block.data.data_len = buf_len;
     bpq_block.data.data_val = buf;
@@ -990,12 +1045,18 @@
 * given a registration handle, listen for count bundles.
 * if count is 0 - listen forever
 * as new bundles arrive save the payload as filename
+* (add _<n> if more than one bundle)
 * if filename is NULL, use the query value as the filename
+* if there is metadata in the bundle and metadata_filename
+* is not NULL, dump the metadata into this file (add _<n> for
+* more than one bundle)  If NULL pretty print to stdout.
 *******************************************************************************/
 int
 recv_bpq(dtn_handle_t handle,
     dtn_timeval_t timeout,
     char * filename,
+    char * metadata_fn,
+    char * query_id,
     int count,
     int verbose)
 {
@@ -1003,8 +1064,17 @@
     int has_bpq_block = 0;
     dtn_bundle_spec_t               bundle_spec;
     dtn_extension_block_t*          bpq_blocks;
+    dtn_extension_block_t*          metadata_blocks;
     dtn_bpq_extension_block_data_t  bpq_block_data;
     dtn_bundle_payload_t            payload;
+    int								decoding_len;
+    u_int64_t						ontology;
+    u_int32_t						metadata_lgth;
+    char *							metadata_str;
+    js_parser						metadata_parser;
+    char							pfn[PATH_MAX], mfn[PATH_MAX];
+    FILE *							mstream;
+
 
     for(j = 0; (count == 0) || (j < count); ++j) {
         memset(&bundle_spec, 0, sizeof(bundle_spec));
@@ -1037,7 +1107,7 @@
         bpq_blocks = bundle_spec.blocks.blocks_val;
 
         for (i = 0; i < num_blocks; ++i) {
-            if (bpq_blocks[i].type == DTN_BPQ_BLOCK_TYPE) {
+            if (bpq_blocks[i].type == QUERY_EXTENSION_BLOCK) {
                 has_bpq_block = 1;
 
                 if (verbose) fprintf(stdout, "bundle contains a "
@@ -1060,16 +1130,86 @@
                     break;
                 }
 
+                if (strlen(query_id) > 0){
+                	if ((bpq_block_data.query_id.query_id_len != (strlen(query_id) + 1)) ||
+                		((strcmp(bpq_block_data.query_id.query_id_val, query_id) != 0))) {
+                		fprintf(stderr, "incoming query_id (%s) does not match expected value",
+                				bpq_block_data.query_id.query_id_val);
+                		err = 1;
+                		break;
+                	}
+                } else {
+                	if (verbose) {
+                		printf("Incoming query id is %s", bpq_block_data.query_id.query_id_val);
+                	}
+                }
+
                 if (verbose) fprintf(stdout, "BPQ query(%s)\n", bpq_block_data.query.query_val);
-                if (filename == NULL)
-                    strncpy(filename, bpq_block_data.query.query_val, PATH_MAX);
-    
+                if (strlen(filename) == 0) {
+                	if (count > 1) {
+                		snprintf(pfn, PATH_MAX, "%s_%d",
+                				 bpq_block_data.query.query_val, (j + 1));
+                	}else {
+                		strncpy(pfn, bpq_block_data.query.query_val, PATH_MAX);
+                	}
+                } else {
+                	if (count > 1) {
+                   		snprintf(pfn, PATH_MAX, "%s_%d", filename, (j + 1));
+                	} else {
+                		strncpy(pfn, filename, PATH_MAX);
+                	}
+                }
+                if (verbose) fprintf(stdout, "Writing payload to %s\n", pfn);
                 break;
             }
-        }
+            // Check for metadata block
+            num_blocks = bundle_spec.metadata.metadata_len;
+            metadata_blocks = bundle_spec.metadata.metadata_val;
+
+            ontology = 0xffffffff;
+
+            for (i = 0; i < num_blocks; ++i) {
+            	// Decode Ontology
+            	if ( (decoding_len = sdnv_decode (metadata_blocks[i].data.data_val,
+            			 	 	 	 	 	 	  // Nul terminated
+            									  metadata_blocks[i].data.data_len - 1,
+            	    							  &ontology)) == -1 ) {
+            	        fprintf (stderr, "Error decoding metadata ontology\n");
+            	        return -1;
+            	}
+            	// Assume only one JSON metadata block
+            	metadata_str = &metadata_blocks[i].data.data_val[decoding_len];
+				// Length includes Nul terminator
+            	metadata_lgth = metadata_blocks[i].data.data_len - decoding_len;
+            	if (ontology == JSON_METADATA_BLOCK) {
+            		break;
+            	}
+            }
+            if (ontology != JSON_METADATA_BLOCK) {
+				if (verbose) fprintf(stdout, "No JSON metadata in bundle %d", (j + 1));
+			} else{
+				// Extract metadata and check is valid JSON
+				if (json_parser(&metadata_parser, metadata_str) == JS_SUCCESS) {
+					if (strlen(metadata_fn) > 0) {
+						if (count > 1) {
+							snprintf(mfn, PATH_MAX, "%s_%d", metadata_fn, (j + 1));
+						} else {
+							strcpy(mfn, metadata_fn);
+						}
+					} else {
+						snprintf(mfn, PATH_MAX, "%s.mdt", pfn);
+					}
+				} else {
+					fprintf(stderr, "Unable to parse metadata in bundle %d\n", (j + 1));
+					return -1;
+				}
+				if (verbose) fprintf(stdout, "Metadata written to %s\n", mfn);
+			}
+		}
+
 
         if(!has_bpq_block) {
-            fprintf(stderr, "no bpq block found in bundle:\n");
+            fprintf(stderr, "no bpq block found in bundle %d:\n", (j + 1));
             for (i = 0; i < num_blocks; ++i)
                 fprintf(stderr, "\tblock[%d] : type = %d\n", i, bpq_blocks[i].type);
 
@@ -1080,18 +1220,34 @@
             continue;
 
         // handle the payload file
-        ret = handle_file_transfer(bundle_spec, payload, filename, verbose);
+        ret = handle_file_transfer(bundle_spec, payload, pfn, verbose);
         if (ret != DTN_SUCCESS) {
             fprintf(stderr, "error handling file transfer: %d\n", ret);
         } else if (verbose) {
             fprintf(stdout, "sucessfully handled file transfer\n");        
         }
+
+        // Write out metadata if any
+        if (ontology == JSON_METADATA_BLOCK) {
+        	if ((mstream = fopen(mfn, "w")) == NULL) {
+        		fprintf(stderr, "Unable to opoen metadata file (%s) for writing.\n", mfn);
+        		return -1;
+        	}
+        	if (fwrite(metadata_str, metadata_lgth, sizeof(*metadata_str), mstream) != metadata_lgth) {
+        		fprintf(stderr, "Write of metadata in file (%s) failed (%s)", mfn, strerror(errno));
+        		fclose(mstream);
+        		return -1;
+        	}
+        	fclose(mstream);
+        	if (verbose) fprintf(stdout, "Metadata successfully written to file (%s)", mfn);
+
+        }
     
         dtn_free_payload(&payload);  
     }
     return ret;
 }
-
+#endif
 /*******************************************************************************
 * main:
 *******************************************************************************/
@@ -1107,6 +1263,9 @@
     char dest_eid_name[PATH_MAX];
     char reply_eid_name[PATH_MAX];
     char filename[PATH_MAX];
+    char metadata[PATH_MAX];
+    char metadata_fn[PATH_MAX];
+    char query_id[PATH_MAX];
     char query[PATH_MAX];
     int query_type = DTN_BPQ_LITERAL;
     int matching_rule = BPQ_MATCHING_RULE_EXACT;
@@ -1127,15 +1286,21 @@
     memset( reg_eid_name,   0, sizeof(char) * PATH_MAX );
     memset( src_eid_name,   0, sizeof(char) * PATH_MAX );
     memset( dest_eid_name,  0, sizeof(char) * PATH_MAX );
-    memset( reply_eid_name,  0, sizeof(char) * PATH_MAX );
+    memset( reply_eid_name, 0, sizeof(char) * PATH_MAX );
     memset( filename,       0, sizeof(char) * PATH_MAX );
     memset( query,          0, sizeof(char) * PATH_MAX );
+    memset( metadata,       0, sizeof(char) * PATH_MAX );
+    memset( metadata_fn,    0, sizeof(char) * PATH_MAX );
+    memset( query_id,       0, sizeof(char) * PATH_MAX );
 
     parse_options(argc, argv,
         src_eid_name,
         dest_eid_name,
         reply_eid_name,
         filename,
+        metadata,
+        metadata_fn,
+        query_id,
         query,
         &query_type,
         &matching_rule,
@@ -1160,11 +1325,14 @@
     validate_options(src_eid_name,
         dest_eid_name,
         reply_eid_name,
+        metadata,
+        query_id,
         query,
         query_type,
         matching_rule,
         mode,
-        bundle_expiry);
+        bundle_expiry,
+        verbose);
 
     // open the ipc handle
     if (verbose) printf("opening connection to dtn router...\n");
@@ -1215,22 +1383,22 @@
         exit(1); \
     }
     case DTN_BPQ_SEND:
-        TRY( send_bpq(handle, regid, &src_eid, &dest_eid, &reply_eid, query,
-                      matching_rule, bundle_expiry, priority,
-                      delivery_options, verbose), "error sending query\n" );
+        TRY( send_bpq(handle, BPQ_BLOCK_KIND_QUERY, &src_eid, &dest_eid, &reply_eid,
+        		      query, query_id, metadata, NULL, matching_rule, bundle_expiry,
+                      priority, delivery_options, verbose), "error sending query\n" );
         break;
 
     case DTN_BPQ_RECV:
-        TRY( recv_bpq(handle, timeout, filename, count, verbose), 
+        TRY( recv_bpq(handle, timeout, filename, metadata_fn, query_id, count, verbose),
              "error receiving query\n" );
         break;
 
     case DTN_BPQ_SEND_RECV:
-        TRY( send_bpq(handle, regid, &src_eid, &dest_eid, &reply_eid, query,
-                      matching_rule, bundle_expiry, priority,
-                      delivery_options, verbose), "error sending query\n" );
+        TRY( send_bpq(handle, BPQ_BLOCK_KIND_QUERY, &src_eid, &dest_eid, &reply_eid,
+        		      query, query_id, metadata, NULL, matching_rule, bundle_expiry,
+        		      priority, delivery_options, verbose), "error sending query\n" );
 
-        TRY( recv_bpq(handle, timeout, filename, count, verbose), 
+        TRY( recv_bpq(handle, timeout, filename, metadata_fn, query_id, count, verbose),
              "error receiving query\n" );
         break;
 
diff -r 52e2b403edd4 -r 00bddbb095de apps/dtnrespond/dtnrespond.c
--- a/apps/dtnrespond/dtnrespond.c	Mon Nov 19 11:58:18 2012 +0000
+++ b/apps/dtnrespond/dtnrespond.c	Fri Jan 04 17:01:21 2013 +0000
@@ -29,6 +29,7 @@
 #include <fcntl.h>
 #include "dtn_api.h"
 #include "sdnv-c.h"
+#include "bpq_api.h"
 
 #define BUFSIZE 16
 #define BLOCKSIZE 8192
@@ -332,7 +333,7 @@
 
     return DTN_SUCCESS;
 }
-
+#if 0
 /*******************************************************************************
 * parse eid:
 *  
@@ -361,7 +362,7 @@
         exit(1);
     }
 }
-
+#endif
 /*******************************************************************************
 * trim whitespace:
 * first move past any leading whitespace 
@@ -548,7 +549,7 @@
 
     return DTN_SUCCESS;
 }
-
+#if 0
 /*******************************************************************************
 * bpq to char array
 * encode the following information:
@@ -854,7 +855,7 @@
 
     return DTN_SUCCESS;
 }
-
+#endif
 /*******************************************************************************
 * send response bpq:
 * build a response bundle containing the queried object file as the payload
@@ -896,6 +897,8 @@
     // set the bpq block data
     response_bpq_block_data.kind = response_kind;
     response_bpq_block_data.matching_rule = query_bpq_block_data->matching_rule;
+    response_bpq_block_data.query_id.query_id_len = query_bpq_block_data->query_id.query_id_len;
+    response_bpq_block_data.query_id.query_id_val = query_bpq_block_data->query_id.query_id_val;
     response_bpq_block_data.query.query_len = query_bpq_block_data->query.query_len;
     response_bpq_block_data.query.query_val = query_bpq_block_data->query.query_val;
 
@@ -905,7 +908,7 @@
     }
 
     // set the bpq block
-    response_bpq_block.type = DTN_BPQ_BLOCK_TYPE;
+    response_bpq_block.type = QUERY_EXTENSION_BLOCK;
     response_bpq_block.flags = BLOCK_FLAG_REPLICATE;
     response_bpq_block.data.data_len = buf_len;
     response_bpq_block.data.data_val = buf;
@@ -924,6 +927,9 @@
     response_bundle_spec.blocks.blocks_len = 1;
     response_bundle_spec.blocks.blocks_val = &response_bpq_block;
 
+    // Currently no metadata for this sort of response
+    // Might be good to extract some sort of search info from file if there was any.
+
 
     // send the bundle, bpq extension and empty payload
     ret = dtn_send(*handle, regid, &response_bundle_spec, &response_payload, &response_bundle_id);
@@ -998,7 +1004,7 @@
         bpq_blocks = bundle_spec.blocks.blocks_val;    
 
         for (j = 0; j < num_blocks; ++j) {
-            if (bpq_blocks[j].type == DTN_BPQ_BLOCK_TYPE) {
+            if (bpq_blocks[j].type == QUERY_EXTENSION_BLOCK) {
 
                 if (verbose) fprintf(stdout, "bundle %d contains a "
                                              "BPQ extension block\n", i);
diff -r 52e2b403edd4 -r 00bddbb095de apps/dtnsend/dtnsend.cc
--- a/apps/dtnsend/dtnsend.cc	Mon Nov 19 11:58:18 2012 +0000
+++ b/apps/dtnsend/dtnsend.cc	Fri Jan 04 17:01:21 2013 +0000
@@ -74,11 +74,12 @@
 // extension/metatdata block information
 class ExtBlock {
 public:
-    ExtBlock(u_int type = 0): metadata_(false) {
+    ExtBlock(u_int type = 0): metadata_(false), ontology_(0) {
         block_.type          = type;
         block_.flags         = 0;
         block_.data.data_len = 0;
         block_.data.data_val = NULL;
+        strcpy(ontology_buf_, "\0\0");
     }
     ~ExtBlock() {
         if (block_.data.data_val != NULL) {
@@ -91,6 +92,7 @@
     ExtBlock(const ExtBlock& o)
     {
         metadata_            = o.metadata_;
+        ontology_			 = o.ontology_;
         block_.type          = o.block_.type;
         block_.flags         = o.block_.flags;
         block_.data.data_len = o.block_.data.data_len;
@@ -100,7 +102,18 @@
     }
     
     bool        metadata() const { return metadata_; }
-    void        set_metadata()   { metadata_ = true; }
+    void        set_metadata(u_int64_t ontology)   {
+		if (ontology > ONTOLOGY_EXPT_MAX) {
+			fprintf(stderr, "Value of ontology greater than maximum allowed\n");
+			exit(1);
+		}
+		if (sdnv_encode(ontology, (u_char*)ontology_buf_, 3) < 0) {
+			fprintf(stderr, "SDNV encoding of ontology failed");
+			exit(1);
+		}
+		metadata_ = true;
+		ontology_ = ontology;
+	}
 
     dtn_extension_block_t & block() { return block_; }
     void set_block_buf(char * buf, u_int len) {
@@ -109,14 +122,24 @@
             block_.data.data_val = NULL;
             block_.data.data_len = 0;
         }
-        block_.data.data_val = buf;
-        block_.data.data_len = len;
+        if (metadata_) {
+        	block_.data.data_val = (char *)malloc(sizeof(char) * (len + strlen(ontology_buf_) + 1));
+        	block_.data.data_len = len + strlen(ontology_buf_);
+        	strcpy(block_.data.data_val, ontology_buf_);
+        	strncat(block_.data.data_val, buf, len);
+        	free(buf);
+        } else {
+			block_.data.data_val = buf;
+			block_.data.data_len = len;
+        }
     }
 
     static unsigned int   num_meta_blocks_;
 
 private:
     bool                  metadata_;
+    u_int64_t			  ontology_;
+    char            	  ontology_buf_[3];
     dtn_extension_block_t block_;
 };
 unsigned int ExtBlock::num_meta_blocks_ = 0;
@@ -418,9 +441,9 @@
     fprintf(stderr, " -W set the do not fragment option\n");
     fprintf(stderr, " -w wait for bundle status reports\n");
     fprintf(stderr, " -E <int> include extension block and specify type\n");
-    fprintf(stderr, " -M <int> include metadata block and specify type\n");
+    fprintf(stderr, " -M <int> include metadata block (type 8) and specify ontology for block\n");
     fprintf(stderr, " -O <int> flags to include in extension/metadata block\n");
-    fprintf(stderr, " -S <string> extension/metadata block content\n");
+    fprintf(stderr, " -S <string> extension/metadata block content (added to ontology for metadata)\n");
     fprintf(stderr, " -a <int> include age extension block and specify age\n");
     fprintf(stderr, " -Z set creation timestamp time to zero\n");
     exit(1);
@@ -430,9 +453,14 @@
 {
     int c, done = 0;
     char arg_type = 0;
+    bool flags_set, data_set;
+    u_int64_t ontology;
 
     progname = argv[0];
 
+    flags_set = false;
+    data_set = false;
+
     while (!done)
     {
         c = getopt(argc, argv, "A:B:vhHr:s:d:e:P:n:woDXFRcC1NWt:p:i:z:E:M:O:S:a:Z");
@@ -526,21 +554,44 @@
             break;
         case 'E':
             ext_blocks.push_back(ExtBlock(atoi(optarg)));
+            flags_set = false;
+            data_set = false;
             break;
         case 'M':
-            ext_blocks.push_back(ExtBlock(atoi(optarg)));
-            ext_blocks.back().set_metadata();
+        	ontology = atoi(optarg);
+        	if (!((ontology == ONTOLOGY_URI) ||
+        		  ((ontology >= ONTOLOGY_EXPT_MIN) &&
+        		   (ontology <= ONTOLOGY_EXPT_MAX)))) {
+        		fprintf(stderr, "-M - ontology type is not in use - available 1, 192-255\n");
+        		exit(1);
+        	}
+            ext_blocks.push_back(ExtBlock(METADATA_BLOCK));
+            ext_blocks.back().set_metadata(ontology);
             ExtBlock::num_meta_blocks_++;
+            flags_set = false;
+            data_set = false;
             break;
         case 'O':
-            if (ext_blocks.size() > 0) {
+            if ((ext_blocks.size() > 0) && !flags_set) {
                 ext_blocks.back().block().flags = atoi(optarg);
+                flags_set = true;
+            } else if (flags_set) {
+            	fprintf(stderr, "Ignoring duplicate flag setting\n");
+            } else {
+            	fprintf(stderr, "No extension or metadata block defined to receive flags\n");
+            	exit(1);
             }
             break;
         case 'S':
-            if (ext_blocks.size() > 0) {
+            if ((ext_blocks.size() > 0) && !data_set) {
                 char * block_buf = strdup(optarg);
                 ext_blocks.back().set_block_buf(block_buf, strlen(block_buf));
+                data_set = true;
+            } else if (data_set) {
+            	fprintf(stderr, "Ignoring duplicate data setting\n");
+            } else {
+            	fprintf(stderr, "No extension or metadata block defined to receive data\n");
+            	exit(1);
             }
             break;
         case 'a':
diff -r 52e2b403edd4 -r 00bddbb095de servlib/bundling/BPQBlock.cc
--- a/servlib/bundling/BPQBlock.cc	Mon Nov 19 11:58:18 2012 +0000
+++ b/servlib/bundling/BPQBlock.cc	Fri Jan 04 17:01:21 2013 +0000
@@ -32,6 +32,7 @@
 BPQBlock::BPQBlock(const Bundle* bundle)
 		: BP_Local(),
 		  Logger("BPQBlock", "/dtn/bundle/bpq"),
+		  query_id_(NULL),
 		  query_val_(NULL),
 		  fragments_("fragments"),
 		  validated_(false)
@@ -67,6 +68,7 @@
 BPQBlock::BPQBlock(const u_char* buf, u_int buf_len)
 		: BP_Local(),
 		  Logger("BPQBlock", "/dtn/bundle/bpq"),
+		  query_id_(NULL),
 		  query_val_(NULL),
 		  fragments_("fragments"),
 		  validated_(false)
@@ -81,6 +83,10 @@
 BPQBlock::~BPQBlock()
 {
     log_debug("BPQBlock: destructor");
+    if ( query_id_ != NULL ){
+        free(query_id_);
+        query_id_ = NULL;
+    }
     if ( query_val_ != NULL ){
         free(query_val_);
         query_val_ = NULL;
@@ -132,6 +138,12 @@
 	// Source EID buffer
 	TEST_ITEM((((u_int64_t)used_len + sdnv_val) > len), (int)sdnv_val,
 			   "source EID longer than remaining buffer");
+	// Query ID length
+	sdnv_len = SDNV::decode(buf, (len - used_len), &sdnv_val);
+	TEST_ITEM((sdnv_len < 0), sdnv_len, "cannot decode SDNV for query ID length");
+	// Query ID buffer
+	TEST_ITEM((((u_int64_t)used_len + sdnv_val) > len), (int)sdnv_val,
+			   "query ID string longer than remaining buffer");
 	// Query length
 	sdnv_len = SDNV::decode(buf, (len - used_len), &sdnv_val);
 	TEST_ITEM((sdnv_len < 0), sdnv_len, "cannot decode SDNV for query length");
@@ -207,6 +219,19 @@
     for (j=0; src_eid != NULL && i < len && j < source_.length(); i++, j++)
         buf[i] = src_eid[j];
 
+    // query-ID-length      SDNV
+    if ( i < len &&
+        (encoding_len = SDNV::encode (query_id_len_, &(buf[i]), len -i)) >= 0 ) {
+        i += encoding_len;
+    } else {
+        log_err("Error encoding BPQ query id length");
+        return -1;
+    }
+
+    // query-ID-value           n-bytes
+    for (j=0; query_id_ != NULL && i < len && j < query_id_len_; i++, j++)
+        buf[i] = query_id_[j];
+
     // query-length         SDNV
     if ( i < len &&
         (encoding_len = SDNV::encode (query_len_, &(buf[i]), len -i)) >= 0 ) {
@@ -271,6 +296,8 @@
     len += SDNV::encoding_len(source_.length());
     len += source_.length();
 
+    len += SDNV::encoding_len(query_id_len_);
+    len += query_id_len_;
     len += SDNV::encoding_len(query_len_);
     len += query_len_;
 
@@ -351,6 +378,7 @@
 	TRY (extract_creation_ts(buf, &buf_index, buf_length),"Error in 'creation_ts'");
 	TRY (extract_source(buf, &buf_index, buf_length), "Error in 'Source EID'");
 
+	TRY (extract_query_id(buf, &buf_index, buf_length), "Error in 'Query ID'");
 	TRY (extract_query(buf, &buf_index, buf_length), "Error in 'Query'");
 	TRY (extract_fragments(buf, &buf_index, buf_length), "Error in 'Fragment specifiers'");
 
@@ -362,6 +390,17 @@
 
 //----------------------------------------------------------------------
 void
+BPQBlock::set_query_id(const u_int query_id_len, u_char* query_id )
+{
+	query_id_ = (u_char*) realloc ( query_id, sizeof(u_char) * query_id_len );
+
+	memcpy(query_id_, query_id, query_id_len);
+
+	query_id_len_ = query_id_len;
+}
+
+//----------------------------------------------------------------------
+void
 BPQBlock::log_block_info(BlockInfo* block)
 {
     ASSERT ( block != NULL);
@@ -509,6 +548,44 @@
 
 //----------------------------------------------------------------------
 int
+BPQBlock::extract_query_id (const u_char* buf, u_int* buf_index, u_int buf_length)
+{
+	int decoding_len = 0;
+
+	if (*buf_index < buf_length &&
+		(decoding_len = SDNV::decode(	&(buf[*buf_index]),
+										buf_length - (*buf_index),
+										&query_id_len_)) >= 0 ) {
+		(*buf_index) += decoding_len;
+		log_debug("BPQBlock::extract_query_id: query ID len = %u", query_id_len_);
+    } else {
+        log_err("Error decoding BPQ query ID length");
+        return BP_FAIL;
+	}
+
+	if (query_id_len_ <= 0) {
+		log_warn("BPQBlock::extract_query: No query id found in block");
+	}
+
+    if (((*buf_index) + query_id_len_) < buf_length) {
+
+    	query_id_ = (u_char*) malloc ( sizeof(u_char) * query_id_len_ );
+
+    	memcpy(query_id_, &(buf[*buf_index]), query_id_len_);
+
+    	(*buf_index) += query_id_len_;
+    	log_debug("BPQBlock::extract_query_id: query id value = %s", query_id_);
+
+    } else {
+        log_err("Error extracting query id value");
+        return BP_FAIL;
+    }
+
+    return BP_SUCCESS;
+}
+
+//----------------------------------------------------------------------
+int
 BPQBlock::extract_query (const u_char* buf, u_int* buf_index, u_int buf_length)
 {
 	int decoding_len = 0;
diff -r 52e2b403edd4 -r 00bddbb095de servlib/bundling/BPQBlock.h
--- a/servlib/bundling/BPQBlock.h	Mon Nov 19 11:58:18 2012 +0000
+++ b/servlib/bundling/BPQBlock.h	Fri Jan 04 17:01:21 2013 +0000
@@ -82,6 +82,8 @@
     u_int           		matching_rule() const { return matching_rule_; }
     const BundleTimestamp& 	creation_ts()  	const { return creation_ts_; }
     const EndpointID& 		source()        const { return source_; }
+    u_int           		query_id_len()  const { return query_id_len_; }
+    u_char*        		 	query_id()      const { return query_id_; }
     u_int           		query_len()     const { return query_len_; }
     u_char*        		 	query_val()     const { return query_val_; }
     u_int           		length()        const;
@@ -94,7 +96,8 @@
 
     /// @{ Mutating accessors
     void        set_creation_ts(const BundleTimestamp &ts) { creation_ts_ = ts; }
-    void        set_source(const EndpointID& eid) { source_ =eid; }
+    void        set_source(const EndpointID& eid) { source_ = eid; }
+    void		set_query_id(const u_int query_id_len, u_char* query_id );
     /// @}
     /**
      * Add the new fragment in sorted order
@@ -111,6 +114,7 @@
     int extract_matching_rule	(const u_char* buf, u_int* buf_index, u_int buf_length);
     int extract_creation_ts		(const u_char* buf, u_int* buf_index, u_int buf_length);
     int extract_source			(const u_char* buf, u_int* buf_index, u_int buf_length);
+    int extract_query_id		(const u_char* buf, u_int* buf_index, u_int buf_length);
     int extract_query			(const u_char* buf, u_int* buf_index, u_int buf_length);
     int extract_fragments		(const u_char* buf, u_int* buf_index, u_int buf_length);
 
@@ -118,6 +122,8 @@
     u_int matching_rule_;       	///< Exact
     BundleTimestamp creation_ts_;	///< Original Creation Timestamp
     EndpointID source_;				///< Original Source EID
+    u_int query_id_len_;			///< Length of Query ID
+    u_char* query_id_;				///< Query ID used to match queries and responses
     u_int query_len_;           	///< Length of the query value
     u_char* query_val_;         	///< Query value
     BPQFragmentList fragments_;  	///< List of fragments returned
diff -r 52e2b403edd4 -r 00bddbb095de servlib/bundling/BPQBlockProcessor.cc
--- a/servlib/bundling/BPQBlockProcessor.cc	Mon Nov 19 11:58:18 2012 +0000
+++ b/servlib/bundling/BPQBlockProcessor.cc	Fri Jan 04 17:01:21 2013 +0000
@@ -33,7 +33,8 @@
 template <> BPQBlockProcessor*
 oasys::Singleton<BPQBlockProcessor>::instance_ = NULL;
 
-
+// Initialise  transfer_query_id_ flag class variable.
+u_int16_t BPQBlockProcessor::transfer_query_id_ = 0;
 
 //----------------------------------------------------------------------
 BPQBlockProcessor::BPQBlockProcessor() :
@@ -72,6 +73,8 @@
     log_info_p(LOG, "     BPQBlock:");
     log_info_p(LOG, "         kind: %d", bpq_block->kind());
     log_info_p(LOG, "matching rule: %d", bpq_block->matching_rule());
+    log_info_p(LOG, " query_id_len: %d", bpq_block->query_id_len());
+    log_info_p(LOG, " query_id_val: %s", bpq_block->query_id());
     log_info_p(LOG, "    query_len: %d", bpq_block->query_len());
     log_info_p(LOG, "    query_val: %s", bpq_block->query_val());
 
@@ -254,6 +257,7 @@
 BPQBlockProcessor::init_block(BlockInfo*    block,
                               BlockInfoVec* block_list,
                               Bundle*       bundle,
+                              u_int16_t     transfer_flags,
                               u_int8_t      type,
                               u_int8_t      flags,
                               const u_char* bp,
@@ -264,11 +268,38 @@
 		log_err_p("/bundling/extblock/BPQBlockProcessor",
 				  "Supplied BPQ block data was invalid");
 	}
-	// If a bundle is supplied as a parameter use its creation_ts and source as the
-	// original values for this BPQBlock - otherwise assume they are right already.
+	// If a bundle is supplied as a parameter and transfer_flags are set appropriately:
+	//  - use its creation_ts and source as the original values for this BPQBlock
+	//  - copy the query id (from query to response)
 	if (bundle != NULL) {
-		bpq_block->set_creation_ts(bundle->creation_ts());
-		bpq_block->set_source(bundle->source());
+		if (transfer_flags & BlockProcessor::transfer_src_ts()) {
+			log_debug_p(LOG, "Setting BPQ creation source and timestamp");
+			bpq_block->set_creation_ts(bundle->creation_ts());
+			bpq_block->set_source(bundle->source());
+		}
+		if (transfer_flags & BPQBlockProcessor::transfer_query_id()) {
+			// Copy the query ID from query to response
+			const BlockInfo* bi_bpq;
+			BPQBlock* query_block;
+		    if( ((bi_bpq = bundle->recv_blocks().find_block(BundleProtocol::QUERY_EXTENSION_BLOCK)) != NULL) ||
+		        ((bi_bpq = ((const_cast<Bundle*>(bundle))->api_blocks()->
+		                       find_block(BundleProtocol::QUERY_EXTENSION_BLOCK))) != NULL) ) {
+
+		    	u_int query_id_len;
+		    	u_char *query_id;
+		        log_debug_p(LOG, "bundle %d has BPQ block - transfer query ID", bundle->bundleid());
+
+		        // now check if there is a cache entry for this key
+		        query_block = dynamic_cast<BPQBlock *>(bi_bpq->locals());
+		        ASSERT (block != NULL);
+		        query_id_len = query_block->query_id_len();
+		        query_id = query_block->query_id();
+
+		        bpq_block->set_query_id(query_id_len, query_id);
+		    }
+
+
+		}
 	}
 	size_t new_len= bpq_block->length();
 	typedef oasys::ScratchBuffer<u_char*, 128> local_buf_t;
@@ -277,7 +308,7 @@
 	bpq_block->write_to_buffer(temp_buf->buf(), new_len);
 
 	// Hand off to base class to initialize block
-	BlockProcessor::init_block(block, block_list, bundle, type,
+	BlockProcessor::init_block(block, block_list, bundle, 0, type,
 							   flags, temp_buf->buf(), new_len);
 
 	// Remember BPQBlock in BP_Locals for block
@@ -368,7 +399,7 @@
 		buf->append("Block too short\n");
 		return 0;
 	}
-	buf->appendf("    Original creation ts: %llu.%llu\n", creation_ts.seconds_, creation_ts.seqno_);
+	buf->appendf("    Original creation ts: %llu, seq: %llu\n", creation_ts.seconds_, creation_ts.seqno_);
 
 	// Source EID length     SDNV
 	if ( (q_decoding_len = SDNV::decode (&(content[i]),
@@ -398,6 +429,40 @@
 		return 0;
 	}
 
+	// BPQ query ID length     SDNV
+	if ( (q_decoding_len = SDNV::decode (&(content[i]),
+										len - i,
+										&item_len)) == -1 ) {
+		buf->append("Error decoding BPQ query ID length\n");
+		return 0;
+	}
+	i += q_decoding_len;
+	if (i > len) {
+		buf->append("Block too short\n");
+		return 0;
+	}
+
+	// BPQ query id value      n-bytes
+	if (i < len) {
+		buf->append("    Query ID: ");
+		buf->append((char*)&(content[i]), item_len - 1);
+		if (content[i+item_len-1] == '\0') {
+			buf->append("<nul>");
+		} else {
+			buf->appendf("<0x%x>", (unsigned int)(content[i+item_len]));
+		}
+		buf->appendf(" (length %llu)\n", item_len);
+		i += item_len;
+	} else {
+		buf->append("Error copying BPQ query ID value \n");
+		return 0;
+	}
+
+	if (i > len) {
+		buf->append("Block too short\n");
+		return 0;
+	}
+
 	// BPQ query value length     SDNV
 	if ( (q_decoding_len = SDNV::decode (&(content[i]),
 										len - i,
@@ -406,16 +471,16 @@
 		return 0;
 	}
 	i += q_decoding_len;
-	if (i > len) {
+	if ((i + item_len) > len) {
 		buf->append("Block too short\n");
 		return 0;
 	}
 
 	// BPQ query value            n-bytes
-	if (i < len) {
+	if ((i + item_len) <= len) {
 		buf->append("    Query value: ");
 		buf->append((char*)&(content[i]), item_len - 1);
-		if (content[i+item_len] == '\0') {
+		if (content[i+item_len-1] == '\0') {
 			buf->append("<nul>");
 		} else {
 			buf->appendf("<0x%x>", (unsigned int)(content[i+item_len]));
diff -r 52e2b403edd4 -r 00bddbb095de servlib/bundling/BPQBlockProcessor.h
--- a/servlib/bundling/BPQBlockProcessor.h	Mon Nov 19 11:58:18 2012 +0000
+++ b/servlib/bundling/BPQBlockProcessor.h	Fri Jan 04 17:01:21 2013 +0000
@@ -84,17 +84,31 @@
     virtual void init_block(BlockInfo*    block,
                             BlockInfoVec* block_list,
                             Bundle*		  bundle,
+                            u_int16_t     transfer_flags,
                             u_int8_t      type,
                             u_int8_t      flags,
                             const u_char* bp,
                             size_t        len);
 
+    /**
+     * Get flag indicating query id should be transferred when init_block is used.
+     */
+    static u_int16_t transfer_query_id( void ) {
+    	if (transfer_query_id_ == 0) {
+    		transfer_query_id_ = BlockProcessor::new_transfer_flag();
+    	}
+    	return transfer_query_id_;
+    }
+
     int format(oasys::StringBuffer* buf, BlockInfo *block);
 
     /// @}
 
 //private:
 //    BPQBlock* create_block(const Bundle* const bundle) const;
+
+    /// Transfer flag value indicating quiery id should be put in new block
+    static u_int16_t transfer_query_id_;
 };
 
 } // namespace dtn
diff -r 52e2b403edd4 -r 00bddbb095de servlib/bundling/BPQCache.cc
--- a/servlib/bundling/BPQCache.cc	Mon Nov 19 11:58:18 2012 +0000
+++ b/servlib/bundling/BPQCache.cc	Fri Jan 04 17:01:21 2013 +0000
@@ -557,8 +557,10 @@
 
     // concatenate matching rule and query value
     std::string input;
-    char matching_rule = (char)block->matching_rule();
-    input.append(&matching_rule);
+    char matching_rule[2];
+    matching_rule[0] = (char)block->matching_rule();
+    matching_rule[1] = '\0';
+    input.append(matching_rule);
     input.append((char*)block->query_val());
 
     key->append(input);
diff -r 52e2b403edd4 -r 00bddbb095de servlib/bundling/BPQResponse.cc
--- a/servlib/bundling/BPQResponse.cc	Mon Nov 19 11:58:18 2012 +0000
+++ b/servlib/bundling/BPQResponse.cc	Fri Jan 04 17:01:21 2013 +0000
@@ -100,7 +100,9 @@
         BlockInfo* new_bi = new_response->api_blocks()->append_block(new_bp);
         new_bp->init_block( new_bi,
                             new_response->api_blocks(),
-                            NULL, // Already have original source and creation_ts in extension data
+                            query,
+                            BPQBlockProcessor::transfer_query_id(),
+                            // Already have original source and creation_ts in response data
                             current_bi.type(),
                             current_bi.flags(),
                             data,
@@ -143,7 +145,9 @@
         BlockInfo* new_bi = new_response->mutable_recv_blocks()->append_block(new_bp);
         new_bp->init_block( new_bi,
                             new_response->mutable_recv_blocks(),
-                            NULL, // Already have original source and creation_ts in extension data
+                            query,
+                            BPQBlockProcessor::transfer_query_id(),
+                            // Already have original source and creation_ts in response data
                             current_bi.type(),
                             current_bi.flags(),
                             data,
diff -r 52e2b403edd4 -r 00bddbb095de servlib/bundling/BlockProcessor.cc
--- a/servlib/bundling/BlockProcessor.cc	Mon Nov 19 11:58:18 2012 +0000
+++ b/servlib/bundling/BlockProcessor.cc	Fri Jan 04 17:01:21 2013 +0000
@@ -29,6 +29,10 @@
 
 static const char* log = "/dtn/bundle/protocol";
 
+// Initialise transfer flag class variables
+u_int16_t BlockProcessor::transfer_flags_ = 1;
+u_int16_t BlockProcessor::transfer_src_ts_ = 0;
+
 //----------------------------------------------------------------------
 BlockProcessor::BlockProcessor(int block_type)
     : block_type_(block_type)
@@ -510,12 +514,15 @@
 BlockProcessor::init_block(BlockInfo*    block,
                            BlockInfoVec* block_list,
                            Bundle*       bundle,
+                           u_int16_t     transfer_flags,
                            u_int8_t      type,
                            u_int8_t      flags,
                            const u_char* bp,
                            size_t        len)
 {
 	(void)bundle; // Not used in generic case
+	(void)transfer_flags; // Not used in generic case
+
 	ASSERT(block->owner() != NULL);
     generate_preamble(block_list, block, type, flags, len);
     ASSERT(block->data_offset() != 0);
diff -r 52e2b403edd4 -r 00bddbb095de servlib/bundling/BlockProcessor.h
--- a/servlib/bundling/BlockProcessor.h	Mon Nov 19 11:58:18 2012 +0000
+++ b/servlib/bundling/BlockProcessor.h	Fri Jan 04 17:01:21 2013 +0000
@@ -34,6 +34,8 @@
 #define BP_SUCCESS (int)(0)
 #define BP_FAIL    (int)(-1)
 
+
+
 /**
  * Base class for the protocol handling of bundle blocks, including
  * the core primary and payload handling, security, and other
@@ -228,6 +230,8 @@
      * General hook to set up a block with the given contents. Used
      * for creating generic extension blocks coming from the API.
      * Can be specialized for specific block types.
+     * Specialization can make use of bundle and transfer_flags to
+     * move information from the bundle into the block being created.
      * Also used when testing bundle protocol routines.
      * If the block has a list of EIDs, the list should be attached
      * to the block before calling this routine. The EIDs will be
@@ -236,10 +240,21 @@
     virtual void init_block(BlockInfo*    block,
                             BlockInfoVec* block_list,
                             Bundle*		  bundle,
+                            u_int16_t     transfer_flags,
                             u_int8_t      type,
                             u_int8_t      flags,
                             const u_char* bp,
-                    size_t        len);
+                            size_t        len);
+
+    /**
+     * Get flag indicating source timestamp should be transferred when init_block is used.
+     */
+    static u_int16_t transfer_src_ts( void ) {
+    	if (transfer_src_ts_ == 0) {
+    		transfer_src_ts_ = new_transfer_flag();
+    	}
+    	return transfer_src_ts_;
+    }
     
     /**
      * Return a one-line representation of the block.
@@ -273,9 +288,24 @@
                            u_int64_t     flags,
                            u_int64_t     data_length);
     
+    /**
+     * Get a new transfer flag
+     */
+    static u_int16_t new_transfer_flag(void) { u_int16_t rslt = transfer_flags_;
+                                                transfer_flags_ <<= 1;
+                                                ASSERT(transfer_flags_ != 0);
+                                                return rslt;
+											  }
 private:
     /// The block typecode for this handler
     int block_type_;
+
+    /// Transfer flags allocated for use by specialisations of init_block
+    /// Indicates values to be transferred from the bundle into a block
+    static u_int16_t transfer_flags_;
+
+    /// Transfer flag value indicating source timestamp should be put in new block
+    static u_int16_t transfer_src_ts_;
 };
 
 } // namespace dtn
diff -r 52e2b403edd4 -r 00bddbb095de servlib/bundling/MetadataBlock.cc
--- a/servlib/bundling/MetadataBlock.cc	Mon Nov 19 11:58:18 2012 +0000
+++ b/servlib/bundling/MetadataBlock.cc	Fri Jan 04 17:01:21 2013 +0000
@@ -33,11 +33,11 @@
 unsigned int MetadataBlock::index_ = 0;
 
 //----------------------------------------------------------------------
-MetadataBlock::MetadataBlock(u_int64_t type, u_char* buf, u_int32_t len):
+MetadataBlock::MetadataBlock(u_int64_t ontology, u_char* buf, u_int32_t len):
     lock_("MetadataBlock"), id_(MetadataBlock::get_next_index()),
     block_(NULL), generated_(true), error_(false),
     source_id_(0), source_(false), flags_(0),
-    ontology_(type), metadata_(NULL), metadata_len_(0)
+    ontology_(ontology), metadata_(NULL), metadata_len_(0)
 {
     if (len > 0) {
         ASSERT(buf != NULL);
@@ -48,12 +48,12 @@
 }
 
 //----------------------------------------------------------------------
-MetadataBlock::MetadataBlock(unsigned int source_id, u_int64_t type,
+MetadataBlock::MetadataBlock(unsigned int source_id, u_int64_t ontology,
                              u_char* buf, u_int32_t len):
     lock_("MetadataBlock"), id_(MetadataBlock::get_next_index()),
     block_(NULL), generated_(true), error_(false),
     source_id_(source_id), source_(true), flags_(0),
-    ontology_(type), metadata_(NULL), metadata_len_(0)
+    ontology_(ontology), metadata_(NULL), metadata_len_(0)
 {
     if (len > 0) {
         ASSERT(buf != NULL);
@@ -100,7 +100,7 @@
 void
 MetadataBlock::set_flags(u_int64_t flags)
 {
-    ASSERT(generated_);
+    // ASSERT(generated_);
     flags_ = flags;
 }
 
diff -r 52e2b403edd4 -r 00bddbb095de servlib/bundling/MetadataBlock.h
--- a/servlib/bundling/MetadataBlock.h	Mon Nov 19 11:58:18 2012 +0000
+++ b/servlib/bundling/MetadataBlock.h	Fri Jan 04 17:01:21 2013 +0000
@@ -48,9 +48,9 @@
         source_id_(0), source_(false), flags_(0),
         ontology_(0), metadata_(NULL), metadata_len_(0) {}
     
-    MetadataBlock(u_int64_t type, u_char* buf, u_int32_t len);
+    MetadataBlock(u_int64_t ontology, u_char* buf, u_int32_t len);
     
-    MetadataBlock(unsigned int source_id, u_int64_t type,
+    MetadataBlock(unsigned int source_id, u_int64_t ontology,
                   u_char* buf, u_int32_t len);
     
     MetadataBlock(oasys::Builder& builder): lock_("MetadataBlock"),
@@ -84,6 +84,11 @@
     void set_ontology(u_int64_t ontology) { ontology_ = ontology; }
     void set_metadata(u_char *buf, u_int32_t len);
     
+    // Known ontology values
+    static const u_int64_t ONTOLOGY_URI = 1;
+    static const u_int64_t ONTOLOGY_EXPT_MIN = 192;
+    static const u_int64_t ONTOLOGY_EXPT_MAX = 255;
+
     /**
      * Mark the metadata block for removal from the bundle on the
      * specified outgoing link.
diff -r 52e2b403edd4 -r 00bddbb095de servlib/bundling/MetadataBlockProcessor.cc
--- a/servlib/bundling/MetadataBlockProcessor.cc	Mon Nov 19 11:58:18 2012 +0000
+++ b/servlib/bundling/MetadataBlockProcessor.cc	Fri Jan 04 17:01:21 2013 +0000
@@ -372,7 +372,12 @@
     u_char *  buf = block->data();
     u_int32_t len = block->data_length();
 
-    // Read the metadata block ontology.
+    char buf2[2000];
+    for (u_int32_t i = 0; i <len; i++)
+    	sprintf(&buf2[2*i], "%02x", buf[i]);
+    log_info_p(log, "Buf: %s Len: %d", buf2, len);
+
+   // Read the metadata block ontology.
     int ontology_len = 0;
     u_int64_t ontology = 0;
     if ((ontology_len = SDNV::decode(buf, len, &ontology)) < 0) {
@@ -384,11 +389,24 @@
     buf += ontology_len;
     len -= ontology_len;
 
+    // Check for recognizable Ontology values
+    if (!((ontology == MetadataBlock::ONTOLOGY_URI) ||
+    	  ((ontology >= MetadataBlock::ONTOLOGY_EXPT_MIN) &&
+    	   (ontology <= MetadataBlock::ONTOLOGY_EXPT_MAX)))) {
+    	log_err_p(log, "MetadataBlockProcessor::parse_metadata_ontology: "
+    	                       "invalid ontology value");
+    	metadata->set_block_error();
+    	return false;
+    }
+
     metadata->set_ontology(ontology);
 
+#if 0
+
     // XXX/demmer this doesn't seem to conform to the spec... instead
     // the length should be whatever is left in len after the SDNV for
     // the ontology
+    // xxx/davies Agreed - removing metadata block length stuff
     
     // Read the metadata block data length.
     int length_len = 0;
@@ -409,6 +427,7 @@
         metadata->set_block_error();
         return false;
     }
+#endif
 
     // Set the offset within the buffer to the metadata block ontology data.
     metadata->set_metadata(buf, len);
@@ -452,24 +471,88 @@
 }
 
 //----------------------------------------------------------------------
+void
+MetadataBlockProcessor::init_block(BlockInfo*    block,
+								   BlockInfoVec* block_list,
+								   Bundle*       bundle,
+								   u_int16_t     transfer_flags,
+								   u_int8_t      type,
+								   u_int8_t      flags,
+								   const u_char* bp,
+								   size_t        len)
+{
+	(void)transfer_flags; // Not used for Metadata block
+
+	// Hand off to base class to initialize block
+	BlockProcessor::init_block(block, block_list, bundle, 0, type,
+							   flags, bp, len);
+	block->set_complete(true);
+
+	if (!parse_metadata(bundle, block)) {
+		log_err_p("/bundling/extblock/MetadataBlockProcessor",
+				  "Supplied Metadata block data was invalid");
+
+	}
+	MetadataBlock* meta_block = dynamic_cast<MetadataBlock *>(block->locals());
+	meta_block->set_flags(block->flags());
+
+}
+
+//----------------------------------------------------------------------
 int
 MetadataBlockProcessor::format(oasys::StringBuffer* buf, BlockInfo *block)
 {
-	int i;
 	u_char* content = NULL;
 	int len = 0;
+	int decoding_len;
+	int i = 0;
+	u_int64_t ontology;
+
 
 	if (block!=NULL) {
 		content = block->data();
 		len = block->data_length();
 	}
 
-	buf->append("Metadata");
+	buf->append("Metadata Extension:\n");
 
-	buf->append(": ");
-	for ( i=0; i<10 && i<len; i++ ) {
-		buf->appendf("%c", toascii(content[i]));
+ 	buf->appendf("    Metadata - length %d: ", len);
+
+	for (int j = 0; j < len; j++){
+    	buf->appendf("%02x", content[j]);
+    }
+	buf->append("\n");
+
+	// Metadata Ontology     SDNV
+	if ( (decoding_len = SDNV::decode (&(content[i]),
+										len - i,
+										&ontology)) == -1 ) {
+		buf->append("Error decoding ontology\n");
+		return 0;
 	}
+
+	i += decoding_len;
+	buf->appendf("    Ontology: %llu\n    Metadata as string: ", ontology);
+	if (i > len) {
+		buf->append("Block too short\n");
+		return 0;
+	}
+
+	if ((len - decoding_len) < 20) {
+		for( ; i < len ; i++){
+			buf->appendf("%c", toascii(content[i]));
+		}
+	}else {
+		for (; i<10 ; i++ ) {
+			buf->appendf("%c", toascii(content[i]));
+		}
+		buf->append(" ... ");
+		for (i = (len -10); i < len ; i++ ) {
+			buf->appendf("%c", toascii(content[i]));
+		}
+	}
+	buf->append("\n");
+
 	return(0);
 }
 
diff -r 52e2b403edd4 -r 00bddbb095de servlib/bundling/MetadataBlockProcessor.h
--- a/servlib/bundling/MetadataBlockProcessor.h	Mon Nov 19 11:58:18 2012 +0000
+++ b/servlib/bundling/MetadataBlockProcessor.h	Fri Jan 04 17:01:21 2013 +0000
@@ -65,6 +65,19 @@
                   const LinkRef& link,
                   bool           last);
 
+    /**
+     * Overrides init_block in base class.
+     * Sets up BP_Local data as a MetadataBlock from the supplied data in the (bp,len) pair.
+     */
+    virtual void init_block(BlockInfo*    block,
+                            BlockInfoVec* block_list,
+                            Bundle*		  bundle,
+                            u_int16_t     transfer_flags,
+                            u_int8_t      type,
+                            u_int8_t      flags,
+                            const u_char* bp,
+                            size_t        len);
+
     int format(oasys::StringBuffer* buf, BlockInfo *b = NULL);
     /// @}
 
diff -r 52e2b403edd4 -r 00bddbb095de servlib/cmd/BundleCommand.cc
--- a/servlib/cmd/BundleCommand.cc	Mon Nov 19 11:58:18 2012 +0000
+++ b/servlib/cmd/BundleCommand.cc	Fri Jan 04 17:01:21 2013 +0000
@@ -352,21 +352,29 @@
             
         } else if (strcmp(cmd, "dump_ascii") == 0) {
             size_t len = bundle->payload().length();
-            oasys::StringBuffer buf(len);
-            const u_char* bp = 
-                bundle->payload().read_data(0, len, (u_char*)buf.data());
-            
-            buf.append((const char*)bp, len);            
-            set_result(buf.c_str());
+            if (len > 0) {
+				oasys::StringBuffer buf(len);
+				const u_char* bp =
+					bundle->payload().read_data(0, len, (u_char*)buf.data());
+
+				buf.append((const char*)bp, len);
+				set_result(buf.c_str());
+            } else {
+            	set_result("(Payload is empty");
+            }
             
         } else if (strcmp(cmd, "dump") == 0) {
             size_t len = bundle->payload().length();
-            oasys::HexDumpBuffer buf(len);
-            
-            bundle->payload().read_data(0, len, (u_char*)buf.tail_buf(len));
-            buf.incr_len(len);
-            
-            set_result(buf.hexify().c_str());
+            if (len > 0){
+				oasys::HexDumpBuffer buf(len);
+
+				bundle->payload().read_data(0, len, (u_char*)buf.tail_buf(len));
+				buf.incr_len(len);
+
+				set_result(buf.hexify().c_str());
+            } else {
+            	set_result("(Payload is empty)");
+            }
             
         } else if (strcmp(cmd, "expire") == 0) {
             BundleDaemon::instance()->post_at_head(
diff -r 52e2b403edd4 -r 00bddbb095de servlib/conv_layers/AX25CMConvergenceLayer.cc
--- a/servlib/conv_layers/AX25CMConvergenceLayer.cc	Mon Nov 19 11:58:18 2012 +0000
+++ b/servlib/conv_layers/AX25CMConvergenceLayer.cc	Fri Jan 04 17:01:21 2013 +0000
@@ -86,6 +86,47 @@
 
 //----------------------------------------------------------------------
 bool
+AX25CMConvergenceLayer::init_link(const LinkRef& link,
+                                  int argc, const char* argv[])
+{
+    ASSERT(link != NULL);
+    ASSERT(!link->isdeleted());
+    ASSERT(link->cl_info() == NULL);
+
+    log_debug("adding %s link %s", link->type_str(), link->nexthop());
+
+    // Create a new parameters structure, parse the options, and store
+    // them in the link's cl info slot.
+    AX25CMLinkParams* params = dynamic_cast<AX25CMLinkParams *>(new_link_params());
+    ASSERT(params != NULL);
+
+    // Try to parse the link's next hop, but continue on even if the
+    // parse fails since the hostname may not be resolvable when we
+    // initialize the link. Each subclass is responsible for
+    // re-checking when opening the link.
+    parse_nexthop(link, params);
+
+    const char* invalid;
+    if (! parse_link_params(params, argc, argv, &invalid)) {
+        log_err("error parsing link options: invalid option '%s'", invalid);
+        delete params;
+        return false;
+    }
+
+	// Calls the SeqpacketConvergenceLayer method
+    if (! finish_init_link(link, params)) {
+        log_err("error in finish_init_link");
+        delete params;
+        return false;
+    }
+
+    link->set_cl_info(params);
+
+    return true;
+}
+
+//----------------------------------------------------------------------
+bool
 AX25CMConvergenceLayer::parse_link_params(LinkParams* lparams,
                                         int argc, const char** argv,
                                         const char** invalidp)
@@ -122,7 +163,6 @@
         return false;
     }
 
-
     // continue up to parse the parent class
     return SeqpacketConvergenceLayer::parse_link_params(lparams, argc, argv,
                                                      invalidp);
@@ -141,6 +181,7 @@
     AX25CMLinkParams* params = dynamic_cast<AX25CMLinkParams*>(link->cl_info());
     ASSERT(params != NULL);
 
+    buf->appendf("hexdump: %s\n", params->hexdump_ ? "enabled" : "disabled");
     buf->appendf("local_call: %s\n", params->local_call_.c_str());
     buf->appendf("remote_call: %s\n", params->remote_call_.c_str());
     buf->appendf("digipeater: %s\n", params->digipeater_.c_str());
diff -r 52e2b403edd4 -r 00bddbb095de servlib/conv_layers/AX25CMConvergenceLayer.h
--- a/servlib/conv_layers/AX25CMConvergenceLayer.h	Mon Nov 19 11:58:18 2012 +0000
+++ b/servlib/conv_layers/AX25CMConvergenceLayer.h	Fri Jan 04 17:01:21 2013 +0000
@@ -85,6 +85,7 @@
     friend class AX25Announce;
 
     /// @{ Virtual from ConvergenceLayer
+    bool init_link(const LinkRef& link, int argc, const char* argv[]);
     bool set_link_defaults(int argc, const char* argv[],
                            const char** invalidp);
     void dump_link(const LinkRef& link, oasys::StringBuffer* buf);
@@ -97,7 +98,7 @@
                                    const char** invalidp);
     virtual bool parse_nexthop(const LinkRef& link, LinkParams* params);
     virtual CLConnection* new_connection(const LinkRef& link,
-                                         LinkParams* params);
+										 LinkParams* params);
     /// @}
 
     /**
diff -r 52e2b403edd4 -r 00bddbb095de servlib/conv_layers/BluetoothConvergenceLayer.cc
--- a/servlib/conv_layers/BluetoothConvergenceLayer.cc	Mon Nov 19 11:58:18 2012 +0000
+++ b/servlib/conv_layers/BluetoothConvergenceLayer.cc	Fri Jan 04 17:01:21 2013 +0000
@@ -59,6 +59,47 @@
 
 //----------------------------------------------------------------------
 bool
+BluetoothConvergenceLayer::init_link(const LinkRef& link,
+                                     int argc, const char* argv[])
+{
+    ASSERT(link != NULL);
+    ASSERT(!link->isdeleted());
+    ASSERT(link->cl_info() == NULL);
+
+    log_debug("adding %s link %s", link->type_str(), link->nexthop());
+
+    // Create a new parameters structure, parse the options, and store
+    // them in the link's cl info slot.
+    BluetoothLinkParams* params = dynamic_cast<BluetoothLinkParams *>(new_link_params());
+    ASSERT(params != NULL);
+
+    // Try to parse the link's next hop, but continue on even if the
+    // parse fails since the hostname may not be resolvable when we
+    // initialize the link. Each subclass is responsible for
+    // re-checking when opening the link.
+    parse_nexthop(link, params);
+
+    const char* invalid;
+    if (! parse_link_params(params, argc, argv, &invalid)) {
+        log_err("error parsing link options: invalid option '%s'", invalid);
+        delete params;
+        return false;
+    }
+
+	// Calls the StreamConvergenceLayer method
+    if (! finish_init_link(link, params)) {
+        log_err("error in finish_init_link");
+        delete params;
+        return false;
+    }
+
+    link->set_cl_info(params);
+
+    return true;
+}
+
+//----------------------------------------------------------------------
+bool
 BluetoothConvergenceLayer::parse_link_params(LinkParams* lparams,
                                               int argc, const char** argv,
                                               const char** invalidp)
@@ -70,6 +111,8 @@
     oasys::OptParser p;
 
     p.addopt(new oasys::BdAddrOpt("local_addr",&params->local_addr_));
+    p.addopt(new oasys::BdAddrOpt("remote_addr",&params->remote_addr_));
+    p.addopt(new oasys::UInt8Opt("channel",&params->channel_));
 
     int count = p.parse_and_shift(argc, argv, invalidp);
     if (count == -1) {
diff -r 52e2b403edd4 -r 00bddbb095de servlib/conv_layers/BluetoothConvergenceLayer.h
--- a/servlib/conv_layers/BluetoothConvergenceLayer.h	Mon Nov 19 11:58:18 2012 +0000
+++ b/servlib/conv_layers/BluetoothConvergenceLayer.h	Fri Jan 04 17:01:21 2013 +0000
@@ -92,6 +92,7 @@
     friend class BluetoothAnnounce;
 
     /// @{ virtual from ConvergenceLayer
+    bool init_link(const LinkRef& link, int argc, const char* argv[]);
     bool set_link_defaults(int argc, const char* argv[],
                            const char** invalidp);
     void dump_link(const LinkRef& link, oasys::StringBuffer* buf);
diff -r 52e2b403edd4 -r 00bddbb095de servlib/conv_layers/ConnectionConvergenceLayer.cc
--- a/servlib/conv_layers/ConnectionConvergenceLayer.cc	Mon Nov 19 11:58:18 2012 +0000
+++ b/servlib/conv_layers/ConnectionConvergenceLayer.cc	Fri Jan 04 17:01:21 2013 +0000
@@ -125,7 +125,8 @@
     buf->appendf("data_timeout: %u\n", params->data_timeout_);
     buf->appendf("test_read_delay: %u\n", params->test_read_delay_);
     buf->appendf("test_write_delay: %u\n", params->test_write_delay_);
-    buf->appendf("test_recv_delay: %u\n",params->test_recv_delay_);
+    buf->appendf("test_read_limit: %u\n",params->test_read_limit_);
+    buf->appendf("test_write_limit: %u\n",params->test_write_limit_);
 }
 
 //----------------------------------------------------------------------
diff -r 52e2b403edd4 -r 00bddbb095de servlib/conv_layers/EthConvergenceLayer.cc
--- a/servlib/conv_layers/EthConvergenceLayer.cc	Mon Nov 19 11:58:18 2012 +0000
+++ b/servlib/conv_layers/EthConvergenceLayer.cc	Fri Jan 04 17:01:21 2013 +0000
@@ -81,6 +81,14 @@
 }
 
 //----------------------------------------------------------------------
+bool
+EthConvergenceLayer::set_link_defaults(int argc, const char* argv[],
+                                       const char** invalidp)
+{
+    return parse_params(&EthConvergenceLayer::defaults_, argc, argv, invalidp);
+}
+
+//----------------------------------------------------------------------
 /**
  * Parse variable args into a parameter structure.
  */
@@ -218,6 +226,48 @@
 }
 
 //----------------------------------------------------------------------
+bool
+EthConvergenceLayer::init_link(const LinkRef& link,
+                               int argc, const char* argv[])
+{
+    ASSERT(link != NULL);
+    ASSERT(!link->isdeleted());
+    ASSERT(link->cl_info() == NULL);
+
+    log_debug("adding %s link %s", link->type_str(), link->nexthop());
+
+    // Create a new parameters structure, parse the options, and store
+    // them in the link's cl info slot.
+    Params* params = dynamic_cast<Params *>(new_link_params());
+    ASSERT(params != NULL);
+
+    const char* invalid;
+    if (! parse_params(params, argc, argv, &invalid)) {
+        log_err("error parsing link options: invalid option '%s'", invalid);
+        delete params;
+        return false;
+    }
+
+    link->set_cl_info(params);
+
+    return true;
+}
+
+//----------------------------------------------------------------------
+void
+EthConvergenceLayer::dump_link(const LinkRef& link, oasys::StringBuffer* buf)
+{
+    ASSERT(link != NULL);
+    ASSERT(!link->isdeleted());
+    ASSERT(link->cl_info() != NULL);
+
+    Params* params = dynamic_cast<Params*>(link->cl_info());
+    ASSERT(params != NULL);
+
+    buf->appendf("beacon_interval: %u\n", params->beacon_interval_);
+}
+
+//----------------------------------------------------------------------
 void
 EthConvergenceLayer::delete_link(const LinkRef& link)
 {
diff -r 52e2b403edd4 -r 00bddbb095de servlib/conv_layers/EthConvergenceLayer.h
--- a/servlib/conv_layers/EthConvergenceLayer.h	Mon Nov 19 11:58:18 2012 +0000
+++ b/servlib/conv_layers/EthConvergenceLayer.h	Fri Jan 04 17:01:21 2013 +0000
@@ -131,6 +131,22 @@
     bool close_contact(const ContactRef& contact);
 
     /**
+     * Initialize any CL-specific components of the Link.
+     */
+    bool init_link(const LinkRef& link, int argc, const char* argv[]);
+
+    /**
+     * Set default link options.
+     */
+    bool set_link_defaults(int argc, const char* argv[],
+                           const char** invalidp);
+
+    /**
+     * Dump out CL specific link information.
+     */
+    void dump_link(const LinkRef& link, oasys::StringBuffer* buf);
+
+    /**
      * Delete any CL-specific components of the Link.
      */
     void delete_link(const LinkRef& link);
diff -r 52e2b403edd4 -r 00bddbb095de servlib/conv_layers/NORMConvergenceLayer.cc
--- a/servlib/conv_layers/NORMConvergenceLayer.cc	Mon Nov 19 11:58:18 2012 +0000
+++ b/servlib/conv_layers/NORMConvergenceLayer.cc	Fri Jan 04 17:01:21 2013 +0000
@@ -281,6 +281,13 @@
 }
 
 //----------------------------------------------------------------------
+CLInfo*
+NORMConvergenceLayer::new_link_params()
+{
+    return new NORMParameters(defaults_);
+}
+
+//----------------------------------------------------------------------
 bool
 NORMConvergenceLayer::set_link_defaults(int argc, const char* argv[],
                                         const char** invalidp)
diff -r 52e2b403edd4 -r 00bddbb095de servlib/conv_layers/NORMConvergenceLayer.h
--- a/servlib/conv_layers/NORMConvergenceLayer.h	Mon Nov 19 11:58:18 2012 +0000
+++ b/servlib/conv_layers/NORMConvergenceLayer.h	Fri Jan 04 17:01:21 2013 +0000
@@ -277,6 +277,11 @@
      * Destructor.
      */
     virtual ~NORMConvergenceLayer() {}
+
+    /**
+     * Create a new LinkParams structure.
+     */
+    virtual CLInfo* new_link_params();
  
     /*
      * Set default link options.
diff -r 52e2b403edd4 -r 00bddbb095de servlib/conv_layers/NullConvergenceLayer.cc
--- a/servlib/conv_layers/NullConvergenceLayer.cc	Mon Nov 19 11:58:18 2012 +0000
+++ b/servlib/conv_layers/NullConvergenceLayer.cc	Fri Jan 04 17:01:21 2013 +0000
@@ -49,6 +49,14 @@
 
 //----------------------------------------------------------------------
 bool
+NullConvergenceLayer::set_link_defaults(int argc, const char* argv[],
+                                       const char** invalidp)
+{
+    return parse_link_params(&NullConvergenceLayer::defaults_, argc, argv, invalidp);
+}
+
+//----------------------------------------------------------------------
+bool
 NullConvergenceLayer::parse_link_params(Params* params,
                                         int argc, const char** argv,
                                         const char** invalidp)
@@ -106,6 +114,20 @@
 
 //----------------------------------------------------------------------
 void
+NullConvergenceLayer::dump_link(const LinkRef& link, oasys::StringBuffer* buf)
+{
+    ASSERT(link != NULL);
+    ASSERT(!link->isdeleted());
+    ASSERT(link->cl_info() != NULL);
+
+    Params* params = dynamic_cast<Params*>(link->cl_info());
+    ASSERT(params != NULL);
+
+    buf->appendf("can_transmit: %s\n", params->can_transmit_ ? "yes" : "no");
+}
+
+//----------------------------------------------------------------------
+void
 NullConvergenceLayer::delete_link(const LinkRef& link)
 {
     ASSERT(link != NULL);
diff -r 52e2b403edd4 -r 00bddbb095de servlib/conv_layers/NullConvergenceLayer.h
--- a/servlib/conv_layers/NullConvergenceLayer.h	Mon Nov 19 11:58:18 2012 +0000
+++ b/servlib/conv_layers/NullConvergenceLayer.h	Fri Jan 04 17:01:21 2013 +0000
@@ -44,7 +44,10 @@
 
     /// @{ Virtual from ConvergenceLayer
     bool init_link(const LinkRef& link, int argc, const char* argv[]);
+    bool set_link_defaults(int argc, const char* argv[],
+                           const char** invalidp);
     bool reconfigure_link(const LinkRef& link, int argc, const char* argv[]);
+    void dump_link(const LinkRef& link, oasys::StringBuffer* buf);
     void delete_link(const LinkRef& link);
     bool open_contact(const ContactRef& contact);
     void bundle_queued(const LinkRef& link, const BundleRef& bundle);
diff -r 52e2b403edd4 -r 00bddbb095de servlib/conv_layers/SeqpacketConvergenceLayer.cc
--- a/servlib/conv_layers/SeqpacketConvergenceLayer.cc	Mon Nov 19 11:58:18 2012 +0000
+++ b/servlib/conv_layers/SeqpacketConvergenceLayer.cc	Fri Jan 04 17:01:21 2013 +0000
@@ -137,6 +137,7 @@
     buf->appendf("keepalive_interval: %u\n", params->keepalive_interval_);
     buf->appendf("segment_length: %u\n", params->segment_length_);
     buf->appendf("ack_window: %u\n", params->ack_window_);
+    buf->appendf("cl_version: %u\n", cl_version_);
 }
 
 //----------------------------------------------------------------------
diff -r 52e2b403edd4 -r 00bddbb095de servlib/conv_layers/SerialConvergenceLayer.cc
--- a/servlib/conv_layers/SerialConvergenceLayer.cc	Mon Nov 19 11:58:18 2012 +0000
+++ b/servlib/conv_layers/SerialConvergenceLayer.cc	Fri Jan 04 17:01:21 2013 +0000
@@ -74,6 +74,47 @@
 
 //----------------------------------------------------------------------
 bool
+SerialConvergenceLayer::init_link(const LinkRef& link,
+                                  int argc, const char* argv[])
+{
+    ASSERT(link != NULL);
+    ASSERT(!link->isdeleted());
+    ASSERT(link->cl_info() == NULL);
+
+    log_debug("adding %s link %s", link->type_str(), link->nexthop());
+
+    // Create a new parameters structure, parse the options, and store
+    // them in the link's cl info slot.
+    SerialLinkParams* params = dynamic_cast<SerialLinkParams *>(new_link_params());
+    ASSERT(params != NULL);
+
+    // Try to parse the link's next hop, but continue on even if the
+    // parse fails since the hostname may not be resolvable when we
+    // initialize the link. Each subclass is responsible for
+    // re-checking when opening the link.
+    parse_nexthop(link, params);
+
+    const char* invalid;
+    if (! parse_link_params(params, argc, argv, &invalid)) {
+        log_err("error parsing link options: invalid option '%s'", invalid);
+        delete params;
+        return false;
+    }
+
+	// Calls the StreamConvergenceLayer method
+    if (! finish_init_link(link, params)) {
+        log_err("error in finish_init_link");
+        delete params;
+        return false;
+    }
+
+    link->set_cl_info(params);
+
+    return true;
+}
+
+//----------------------------------------------------------------------
+bool
 SerialConvergenceLayer::parse_link_params(LinkParams* lparams,
                                        int argc, const char** argv,
                                        const char** invalidp)
@@ -85,6 +126,8 @@
     
     p.addopt(new oasys::BoolOpt("hexdump", &params->hexdump_));
     p.addopt(new oasys::StringOpt("initstr", &params->initstr_));
+    p.addopt(new oasys::UIntOpt("ispeed", &params->ispeed_));
+    p.addopt(new oasys::UIntOpt("ospeed", &params->ospeed_));
     p.addopt(new oasys::UIntOpt("sync_interval", &params->sync_interval_));
     
     int count = p.parse_and_shift(argc, argv, invalidp);
@@ -111,7 +154,11 @@
     SerialLinkParams* params = dynamic_cast<SerialLinkParams*>(link->cl_info());
     ASSERT(params != NULL);
     
+    buf->appendf("hexdump: %s\n", params->hexdump_ ? "enabled" : "disabled");
     buf->appendf("initstr: %s\n", params->initstr_.c_str());
+    buf->appendf("ispeed: %d bps\n", params->ispeed_);
+    buf->appendf("ospeed: %d bps\n", params->ospeed_);
+    buf->appendf("sync_interval: %d\n", params->sync_interval_);
 }
 
 //----------------------------------------------------------------------
diff -r 52e2b403edd4 -r 00bddbb095de servlib/conv_layers/SerialConvergenceLayer.h
--- a/servlib/conv_layers/SerialConvergenceLayer.h	Mon Nov 19 11:58:18 2012 +0000
+++ b/servlib/conv_layers/SerialConvergenceLayer.h	Fri Jan 04 17:01:21 2013 +0000
@@ -73,6 +73,7 @@
 
 protected:
     /// @{ Virtual from ConvergenceLayer
+    bool init_link(const LinkRef& link, int argc, const char* argv[]);
     bool set_link_defaults(int argc, const char* argv[],
                            const char** invalidp);
     void dump_link(const LinkRef& link, oasys::StringBuffer* buf);
diff -r 52e2b403edd4 -r 00bddbb095de servlib/conv_layers/StreamConvergenceLayer.cc
--- a/servlib/conv_layers/StreamConvergenceLayer.cc	Mon Nov 19 11:58:18 2012 +0000
+++ b/servlib/conv_layers/StreamConvergenceLayer.cc	Fri Jan 04 17:01:21 2013 +0000
@@ -130,6 +130,7 @@
     buf->appendf("negative_ack_enabled: %u\n", params->negative_ack_enabled_);
     buf->appendf("keepalive_interval: %u\n", params->keepalive_interval_);
     buf->appendf("segment_length: %u\n", params->segment_length_);
+    buf->appendf("cl_version: %u\n", cl_version_);
 }
 
 //----------------------------------------------------------------------
diff -r 52e2b403edd4 -r 00bddbb095de servlib/conv_layers/StreamConvergenceLayer.h
--- a/servlib/conv_layers/StreamConvergenceLayer.h	Mon Nov 19 11:58:18 2012 +0000
+++ b/servlib/conv_layers/StreamConvergenceLayer.h	Fri Jan 04 17:01:21 2013 +0000
@@ -169,7 +169,7 @@
         /**
          * Virtual from SerializableObject
          */
-        virtual void serialize( oasys::SerializeAction *);
+        void serialize( oasys::SerializeAction *);
 
         bool  segment_ack_enabled_;	///< Use per-segment acks
         bool  negative_ack_enabled_;	///< Enable negative acks
diff -r 52e2b403edd4 -r 00bddbb095de servlib/conv_layers/TCPConvergenceLayer.cc
--- a/servlib/conv_layers/TCPConvergenceLayer.cc	Mon Nov 19 11:58:18 2012 +0000
+++ b/servlib/conv_layers/TCPConvergenceLayer.cc	Fri Jan 04 17:01:21 2013 +0000
@@ -72,6 +72,47 @@
 
 //----------------------------------------------------------------------
 bool
+TCPConvergenceLayer::init_link(const LinkRef& link,
+                               int argc, const char* argv[])
+{
+    ASSERT(link != NULL);
+    ASSERT(!link->isdeleted());
+    ASSERT(link->cl_info() == NULL);
+
+    log_debug("adding %s link %s", link->type_str(), link->nexthop());
+
+    // Create a new parameters structure, parse the options, and store
+    // them in the link's cl info slot.
+    TCPLinkParams* params = dynamic_cast<TCPLinkParams *>(new_link_params());
+    ASSERT(params != NULL);
+
+    // Try to parse the link's next hop, but continue on even if the
+    // parse fails since the hostname may not be resolvable when we
+    // initialize the link. Each subclass is responsible for
+    // re-checking when opening the link.
+    parse_nexthop(link, params);
+
+    const char* invalid;
+    if (! parse_link_params(params, argc, argv, &invalid)) {
+        log_err("error parsing link options: invalid option '%s'", invalid);
+        delete params;
+        return false;
+    }
+
+	// Calls the StreamConvergenceLayer method
+    if (! finish_init_link(link, params)) {
+        log_err("error in finish_init_link");
+        delete params;
+        return false;
+    }
+
+    link->set_cl_info(params);
+
+    return true;
+}
+
+//----------------------------------------------------------------------
+bool
 TCPConvergenceLayer::parse_link_params(LinkParams* lparams,
                                        int argc, const char** argv,
                                        const char** invalidp)
@@ -83,6 +124,8 @@
     
     p.addopt(new oasys::BoolOpt("hexdump", &params->hexdump_));
     p.addopt(new oasys::InAddrOpt("local_addr", &params->local_addr_));
+    p.addopt(new oasys::InAddrOpt("remote_addr", &params->remote_addr_));
+    p.addopt(new oasys::UInt16Opt("remote_port", &params->remote_port_));
     
     int count = p.parse_and_shift(argc, argv, invalidp);
     if (count == -1) {
@@ -113,9 +156,10 @@
     TCPLinkParams* params = dynamic_cast<TCPLinkParams*>(link->cl_info());
     ASSERT(params != NULL);
     
+    buf->appendf("hexdump: %s\n", params->hexdump_ ? "enabled" : "disabled");
     buf->appendf("local_addr: %s\n", intoa(params->local_addr_));
     buf->appendf("remote_addr: %s\n", intoa(params->remote_addr_));
-    buf->appendf("remote_port: %d\n", params->remote_port_);
+    buf->appendf("remote_port: %u\n", params->remote_port_);
 }
 
 //----------------------------------------------------------------------
diff -r 52e2b403edd4 -r 00bddbb095de servlib/conv_layers/TCPConvergenceLayer.h
--- a/servlib/conv_layers/TCPConvergenceLayer.h	Mon Nov 19 11:58:18 2012 +0000
+++ b/servlib/conv_layers/TCPConvergenceLayer.h	Fri Jan 04 17:01:21 2013 +0000
@@ -61,7 +61,7 @@
         /**
          * Virtual from SerializableObject
          */
-        virtual void serialize( oasys::SerializeAction *);
+        void serialize( oasys::SerializeAction *);
 
         bool      hexdump_;		///< Log a hexdump of all traffic
         in_addr_t local_addr_;		///< Local address to bind to
@@ -83,6 +83,7 @@
     friend class IPAnnounce;
 
     /// @{ Virtual from ConvergenceLayer
+    bool init_link(const LinkRef& link, int argc, const char* argv[]);
     bool set_link_defaults(int argc, const char* argv[],
                            const char** invalidp);
     void dump_link(const LinkRef& link, oasys::StringBuffer* buf);
diff -r 52e2b403edd4 -r 00bddbb095de servlib/conv_layers/UDPConvergenceLayer.cc
--- a/servlib/conv_layers/UDPConvergenceLayer.cc	Mon Nov 19 11:58:18 2012 +0000
+++ b/servlib/conv_layers/UDPConvergenceLayer.cc	Fri Jan 04 17:01:21 2013 +0000
@@ -49,13 +49,6 @@
 }
 
 //----------------------------------------------------------------------
-CLInfo*
-UDPConvergenceLayer::new_link_params()
-{
-    return new UDPConvergenceLayer::Params(UDPConvergenceLayer::defaults_);
-}
-
-//----------------------------------------------------------------------
 UDPConvergenceLayer::UDPConvergenceLayer()
     : IPConvergenceLayer("UDPConvergenceLayer", "udp")
 {
@@ -68,6 +61,21 @@
 }
 
 //----------------------------------------------------------------------
+CLInfo*
+UDPConvergenceLayer::new_link_params()
+{
+    return new UDPConvergenceLayer::Params(UDPConvergenceLayer::defaults_);
+}
+
+//----------------------------------------------------------------------
+bool
+UDPConvergenceLayer::set_link_defaults(int argc, const char* argv[],
+                                       const char** invalidp)
+{
+    return parse_params(&UDPConvergenceLayer::defaults_, argc, argv, invalidp);
+}
+
+//----------------------------------------------------------------------
 bool
 UDPConvergenceLayer::parse_params(Params* params,
                                   int argc, const char** argv,
@@ -253,6 +261,8 @@
 
     buf->appendf("\tremote_addr: %s remote_port: %d\n",
                  intoa(params->remote_addr_), params->remote_port_);
+    buf->appendf("rate: %u\n", params->rate_);
+    buf->appendf("bucket_depth: %u\n", params->bucket_depth_);
 }
 
 //----------------------------------------------------------------------
diff -r 52e2b403edd4 -r 00bddbb095de servlib/conv_layers/UDPConvergenceLayer.h
--- a/servlib/conv_layers/UDPConvergenceLayer.h	Mon Nov 19 11:58:18 2012 +0000
+++ b/servlib/conv_layers/UDPConvergenceLayer.h	Fri Jan 04 17:01:21 2013 +0000
@@ -63,6 +63,12 @@
     bool init_link(const LinkRef& link, int argc, const char* argv[]);
 
     /**
+     * Set default link options.
+     */
+    bool set_link_defaults(int argc, const char* argv[],
+                           const char** invalidp);
+
+    /**
      * Delete any CL-specific components of the Link.
      */
     void delete_link(const LinkRef& link);
diff -r 52e2b403edd4 -r 00bddbb095de servlib/discovery/Discovery.cc
--- a/servlib/discovery/Discovery.cc	Mon Nov 19 11:58:18 2012 +0000
+++ b/servlib/discovery/Discovery.cc	Fri Jan 04 17:01:21 2013 +0000
@@ -53,8 +53,10 @@
     if (af == "ip")
     {
 #ifdef BBN_IPND_ENABLED
+    	log_debug_p("/dtn/discovery", "IPND discovery selected for ip");
         disc = new IPNDDiscovery(name);
 #else
+    	log_debug_p("/dtn/discovery", "Original IP discovery selected for ip");
         disc = new IPDiscovery(name);
 #endif
     }
diff -r 52e2b403edd4 -r 00bddbb095de test/unit_tests/bundle-protocol-test.cc
--- a/test/unit_tests/bundle-protocol-test.cc	Mon Nov 19 11:58:18 2012 +0000
+++ b/test/unit_tests/bundle-protocol-test.cc	Fri Jan 04 17:01:21 2013 +0000
@@ -385,23 +385,23 @@
     unknown1 = recv_blocks->append_block(unknown1_bp);
     const char* contents = "this is an extension block";
     UnknownBlockProcessor::instance()->
-        init_block(unknown1, recv_blocks, NULL, 0xaa, 0x0,
+        init_block(unknown1, recv_blocks, NULL, 0, 0xaa, 0x0,
                    (const u_char*)contents, strlen(contents));
     
     unknown2 = recv_blocks->append_block(unknown2_bp);
     UnknownBlockProcessor::instance()->
-        init_block(unknown2, recv_blocks, NULL, 0xbb,
+        init_block(unknown2, recv_blocks, NULL, 0, 0xbb,
                    BundleProtocol::BLOCK_FLAG_REPLICATE, 0, 0);
     
     payload  = recv_blocks->append_block(payload_bp);
     UnknownBlockProcessor::instance()->
-        init_block(payload, recv_blocks, NULL,
+        init_block(payload, recv_blocks, NULL, 0,
                    BundleProtocol::PAYLOAD_BLOCK,
                    0, (const u_char*)"test payload", strlen("test payload"));
 
     unknown3 = recv_blocks->append_block(unknown3_bp);
     UnknownBlockProcessor::instance()->
-        init_block(unknown3, recv_blocks, NULL, 0xcc,
+        init_block(unknown3, recv_blocks, NULL, 0, 0xcc,
                    BundleProtocol::BLOCK_FLAG_REPLICATE |
                    BundleProtocol::BLOCK_FLAG_LAST_BLOCK,
                    (const u_char*)contents, strlen(contents));
@@ -451,13 +451,13 @@
     
     const char* contents = "this is an extension block";
     UnknownBlockProcessor::instance()->
-        init_block(unknown, recv_blocks, NULL, 0xaa,
+        init_block(unknown, recv_blocks, NULL, 0, 0xaa,
                    BundleProtocol::BLOCK_FLAG_EID_REFS,
                    (const u_char*)contents, strlen(contents));
 
     payload  = recv_blocks->append_block(payload_bp);
     UnknownBlockProcessor::instance()->
-        init_block(payload, recv_blocks, NULL,
+        init_block(payload, recv_blocks, NULL, 0,
                    BundleProtocol::PAYLOAD_BLOCK,
                    BundleProtocol::BLOCK_FLAG_LAST_BLOCK,
                    (const u_char*)"test payload", strlen("test payload"));
